"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[395],{395:(e,s,t)=>{t.r(s),t.d(s,{AcceptMessage:()=>H,AcceptObserver:()=>O,ConnectMessage:()=>E,ConnectMessageObserver:()=>V,ConnectionRefusedError:()=>C,ErrorType:()=>m,ErrorTypeMap:()=>T,HandshakeMessage:()=>L,HandshakeObserver:()=>w,IncomingMessageType:()=>p,InvalidProviderError:()=>b,KeyReferrerMismatchError:()=>I,MP_SDK:()=>u,OutgoingMessageType:()=>v,RejectMessage:()=>B,RejectObserver:()=>N,connect:()=>k,version:()=>S});class n{constructor(e){this.targetWindow=e,this.messageObserver=null,this.onMessage=e=>{if(this.messageObserver){const s=e.data;this.messageObserver.notify(Object.assign({},s),{id:s.fromId,origin:e.origin,source:e.source},e.data.timestamp)}}}listen(e){this.messageObserver||(this.messageObserver=e,this.targetWindow.addEventListener("message",this.onMessage))}stopListening(){this.targetWindow.removeEventListener("message",this.onMessage),this.messageObserver=null}}class r{constructor(e,s="*"){this.targetWindow=e,this.targetOrigin=s}send(e,s){this.targetWindow.postMessage(e,this.targetOrigin)}}class i{constructor(e){this.messageReceiver=e}notify(e,s){this.messageReceiver.onMessageReceived(e,s)}}class o{constructor(){this.values={}}add(e,s){this.getValuesAtKey(e).push(s)}remove(e,s){const t=this.values[e];if(t){const e=t.indexOf(s);e>-1&&t.splice(e,1)}}removeKey(e){delete this.values[e]}getValuesAtKey(e){const s=this.values[e]||[];return this.values[e]=s,s}valuesPerKey(e){return this.getValuesAtKey(e).length}find(e,s){return this.values[e]&&this.values[e].find(s)}get keys(){return Object.keys(this.values)}hasKey(e){return e in this.values}has(e,s){return this.hasKey(e)&&this.values[e].includes(s)}*[Symbol.iterator](){for(const e in this.values)for(const s of this.values[e])yield[e,s]}}Symbol.iterator;class c{constructor(e,s){this.sourceId=e,this.listenerBridge=s,this.observers=new o}init(){const e=new class{constructor(e){this.messenger=e}onMessageReceived(e,s){this.messenger.onMessageReceived(e,s)}}(this),s=new i(e);this.listenerBridge.listen(s)}dispose(){this.listenerBridge.stopListening()}addObserver(e){this.observers.add(e.messageType,e)}removeObserver(e){this.observers.remove(e.messageType,e)}send(e,s,t,n){t.send(Object.assign(Object.assign({},e),{fromId:this.sourceId,toId:s,timestamp:Date.now()}),n)}onMessageReceived(e,s){const t=e.type,n=this.observers.getValuesAtKey(t);if(n)for(const t of n){const n=e.payload||e;t.notify(n,s,e.timestamp)}}}class a{listen(){}stopListening(){}send(){throw Error("The sdk has been disconnected and can't make any new calls")}}class h{constructor(e,s,t){this.sourceId=e,this.targetId=s,this.messageBridge=t,this.observers=new o}static toFilteredMessenger(e,s,t){const n=new d(e.sourceId,e.targetId,e,s);for(const s of t)for(const t of e.observers.getValuesAtKey(s))n.addObserver(t);return n}init(){const e=new class{constructor(e){this.messenger=e}onMessageReceived(e,s){this.messenger.onMessageReceived(e,s)}}(this),s=new i(e);this.messageBridge.listen(s)}dispose(){this.messageBridge.stopListening(),this.messageBridge=new a}addObserver(e){this.observers.add(e.messageType,e)}removeObserver(e){this.observers.remove(e.messageType,e)}send(e){const s=this.sourceId,t=this.targetId;this.messageBridge.send(Object.assign(Object.assign({},e),{fromId:s,toId:t,timestamp:Date.now()}))}onMessageReceived(e,s){if(!this.filterMessageId(e))return;const t=e.type,n=this.observers.getValuesAtKey(t);if(n)for(const t of n){const n=e.payload||e;t.notify(n,s,e.timestamp)}}filterMessageId(e){const s=e.toId,t=e.fromId;return s instanceof Array?s.indexOf(this.sourceId)>-1:(void 0===s||s===this.sourceId)&&t===this.targetId}}class d extends h{constructor(e,s,t,n){super(e,s,new a),this.messenger=t,this.sendFilter=n,this.errorBridge=new a}send(e){this.sendFilter.includes(e.type)?this.messenger.send(e):this.errorBridge.send()}}class l{constructor(e,s,t="*"){this.sourceWindow=e,this.listener=new n(e),this.sender=new r(s,t)}listen(e){this.listener.listen(e)}stopListening(){this.listener.stopListening()}send(e){this.sender.send(e,this.sourceWindow)}}class g{constructor(e,s,t,n,r="*"){this.sourceId=e,this.sourceWindow=s,this.targetId=t,this.targetWindow=n,this.targetOrigin=r}createMessenger(){const e=new l(this.sourceWindow,this.targetWindow,this.targetOrigin);return new h(this.sourceId,this.targetId,e)}}var u,v,p,m,f=t(505),y=function(e,s,t,n){return new(t||(t=Promise))(function(r,i){function o(e){try{a(n.next(e))}catch(e){i(e)}}function c(e){try{a(n.throw(e))}catch(e){i(e)}}function a(e){var s;e.done?r(e.value):(s=e.value,s instanceof t?s:new t(function(e){e(s)})).then(o,c)}a((n=n.apply(e,s||[])).next())})};!function(e){const s=new f.o;e.connect=function(e,t,n){return y(this,void 0,void 0,function*(){let r;try{r=yield e.connect()}finally{e.cancelConnecting()}const i=yield function(e){return y(this,void 0,void 0,function*(){if(!e)throw new Error("Unabled to load the sdk");try{const t=yield s.load(e,"sdk-client");if(t&&t.SdkBuilder&&"function"==typeof t.SdkBuilder)return t.SdkBuilder}catch(e){}throw Error(`Could not load the sdk from ${e}`)})}(r.scriptUrl),o=t.getFactory(r);return function(e,s,t,n){return new s(t,e).build(n)}(n,i,o,r.serializedInterface)})}}(u||(u={})),function(e){e.CONNECT="postmessage.connect"}(v||(v={})),function(e){e.HANDSHAKE="postmessage.handshake",e.ACCEPT="postmessage.accept",e.REJECT="postmessage.reject"}(p||(p={}));class E{constructor(e,s={}){this.type=v.CONNECT,this.payload={bootstrapVersion:e,options:{auth:s.auth,provider:s.provider,sdkType:s.sdkType},applicationKey:s.applicationKey}}}class w{constructor(e){this.receiver=e,this.messageType=p.HANDSHAKE}notify(e,s,t){this.receiver.handshake()}}class O{constructor(e){this.receiver=e,this.messageType=p.ACCEPT}notify(e,s,t){const{sourceId:n,scriptUrl:r,targetId:i,targetOrigin:o}=e,c=e.interface;this.receiver.accept(n,r,c,i,o)}}!function(e){e.CANCELLED="ConnectionCancelled",e.REFUSED="ConnectionRefused",e.INVALID_PROVIDER="InvalidProvider",e.KEY_MISMATCH="KeyReferrerMismatch"}(m||(m={}));class C extends Error{constructor(){super(),this.type=m.REFUSED,this.name="ConnectionRefusedError"}}class b extends Error{constructor(e){super(e),this.type=m.INVALID_PROVIDER,this.name="InvalidProviderError"}}class I extends Error{constructor(e){super(e),this.type=m.KEY_MISMATCH,this.name="KeyReferrerMismatchError"}}const T={[m.REFUSED]:C,[m.KEY_MISMATCH]:I,[m.INVALID_PROVIDER]:b};class N{constructor(e){this.receiver=e,this.messageType=p.REJECT}notify(e,s,t){const n=T[e.errorType];if(n){const s=new n(e.reason);this.receiver.reject(s)}}}class M extends Error{constructor(e){super(e),this.type=m.CANCELLED,this.name="ConnectionCancelledError"}}var D;!function(e){e[e.IDLE=0]="IDLE",e[e.CONNECTING=1]="CONNECTING",e[e.HANDSHAKE=2]="HANDSHAKE",e[e.CONNECTED=3]="CONNECTED",e[e.REJECTED=4]="REJECTED"}(D||(D={}));class A{constructor(e,s,t){this.messenger=e,this.target=s,this.source=t,this.connectionState=D.IDLE,this.connectionPoll=void 0;const n=new class{constructor(e){this.connector=e}handshake(){this.connector.handshake()}accept(e,s,t,n,r){this.connector.accept(e,s,t,n,r)}reject(e){this.connector.reject(e)}}(this);this.handshakeObserver=new w(n),this.acceptObserver=new O(n),this.rejectObserver=new N(n),this.connectionPromise=new Promise((e,s)=>{this.resolveConnection=e,this.rejectConnection=s})}connect(e,s={}){return this.connectionState===D.IDLE&&(this.connectionState=D.CONNECTING,this.messenger.addObserver(this.handshakeObserver),this.messenger.addObserver(this.acceptObserver),this.messenger.addObserver(this.rejectObserver),this.connectionPoll=window.setInterval(()=>{this.messenger.send(new E(e,s),-1,this.target,this.source)},500)),this.connectionPromise}cancelConnecting(){this.connectionState<D.CONNECTED&&(this.stopConnectPolling(),this.rejectConnection(new M("User manually cancelled connection")))}handshake(){this.connectionState<D.HANDSHAKE&&(this.connectionState=D.HANDSHAKE,this.stopConnectPolling(),this.messenger.removeObserver(this.handshakeObserver))}accept(e,s,t,n,r){this.connectionState<D.CONNECTED&&(this.connectionState=D.CONNECTED,this.messenger.removeObserver(this.handshakeObserver),this.messenger.removeObserver(this.acceptObserver),this.messenger.removeObserver(this.rejectObserver),this.stopConnectPolling(),this.resolveConnection({sourceId:e,targetId:n,targetOrigin:r,scriptUrl:s,serializedInterface:t}))}reject(e){this.connectionState<D.CONNECTED&&(this.connectionState=D.REJECTED,this.messenger.removeObserver(this.handshakeObserver),this.messenger.removeObserver(this.acceptObserver),this.messenger.removeObserver(this.rejectObserver),this.stopConnectPolling(),this.rejectConnection(e))}stopConnectPolling(){clearInterval(this.connectionPoll),this.connectionPoll=void 0}}var R=function(e,s,t,n){return new(t||(t=Promise))(function(r,i){function o(e){try{a(n.next(e))}catch(e){i(e)}}function c(e){try{a(n.throw(e))}catch(e){i(e)}}function a(e){var s;e.done?r(e.value):(s=e.value,s instanceof t?s:new t(function(e){e(s)})).then(o,c)}a((n=n.apply(e,s||[])).next())})};const S="3.0";function k(e,s={}){return R(this,void 0,void 0,function*(){return"string"==typeof s?function(e,s){return console.warn("MP_SDK: connecting using an `applicationKey` argument is deprecated. Please add the key to the iframe's URL parameters instead."),K(e,{applicationKey:s})}(e,s):K(e,s)})}function K(e,s={}){const t=(i=e).contentWindow?i.contentWindow:null;var i;if(!t)return Promise.reject("invalid window");const o=Math.floor(1e6*Math.random()),a=new n(window),h=new r(t),d=new c(o,a);d.init();const l=new A(d,h,window);return u.connect(new P(l,d,s),new j(t),window)}class P{constructor(e,s,t){this.connector=e,this.postMessage=s,this.options=t}connect(){return this.connector.connect(S,this.options)}cancelConnecting(){this.postMessage.dispose()}}class j{constructor(e){this.target=e}getFactory(e){return new g(e.sourceId,window,e.targetId,this.target,e.targetOrigin)}}class L{constructor(){this.type=p.HANDSHAKE,this.payload={}}}class H{constructor(e,s,t,n,r){this.type=p.ACCEPT,this.payload={scriptUrl:e,interface:s,sourceId:t,targetId:n,targetOrigin:r},this.interface=s}}class B{constructor(e){this.type=p.REJECT,this.payload={reason:e.message,errorType:e.type},this.reason=e.message}}class V{constructor(e){this.receiver=e,this.messageType=v.CONNECT}notify(e,s){this.receiver.onConnectionReceived(e,s)}}}}]);