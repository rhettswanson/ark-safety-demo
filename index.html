<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ARK Safety Demo (WebComponent + Scene API)</title>

  <!-- Three.js import shim -->
  <script type="importmap">
  {
    "imports": {
      "three": "./three-shim.js",
      "https://unpkg.com/three@%5E0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@^0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0/build/three.module.js?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0/build/three.module.js": "./three-shim.js"
    }
  }
  </script>

  <!-- Matterport WebComponent -->
  <script type="module" src="https://unpkg.com/@matterport/webcomponent@0.1.45/dist/matterport-viewer.esm.js?module"></script>

  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e8edf2; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    .app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { display: flex; gap: .5rem; align-items: center; padding: .75rem 1rem; background: #11161d; border-bottom: 1px solid #1f2a37; }
    header .tag { font-weight: 700; letter-spacing:.06em; opacity: .9; }
    header button { all: unset; background: #1f2a37; padding: .45rem .7rem; border-radius: .5rem; cursor: pointer; border: 1px solid #2b3949; }
    header button:hover { background:#243244; }
    header button:active { background:#1b2633; }
    header button[disabled] { opacity: .45; cursor: not-allowed; filter: grayscale(0.3); }
    header .spacer { flex: 1 1 auto; }
    header .status { font-size:.9rem; opacity:.85; }
    header .dot { display:inline-block; width:.6rem; height:.6rem; border-radius:50%; margin-right:.4rem; vertical-align:middle; background:#596b7d; }
    header .dot.ok { background:#34d399; }
    header .dot.warm { background:#f59e0b; }
    header .dot.err { background:#ef4444; }

    .stage { position: relative; height: 100%; overflow: hidden; background: #000; }
    matterport-viewer { position: absolute; inset: 0; width: 100%; height: 100%; }
    .hud { position: absolute; left: 12px; bottom: 12px; background: rgba(9,12,17,.72); border: 1px solid rgba(64,86,110,.55); padding: .35rem .6rem; border-radius: .5rem; font-size: .85rem; user-select: none; z-index: 10040; }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <span class="tag">ARK</span>
      <button id="btnPlaceThreat" disabled>Place Threat</button>
      <button id="btnCompute" disabled>Compute Route</button>
      <button id="btnToggleTruth" disabled>Truth Mode: Off</button>
      <button id="btnProbe" disabled>Probe Node</button>
      <button id="btnReset">Reset</button>
      <span class="spacer"></span>
      <span class="status" id="status"><span class="dot warm"></span>Connecting…</span>
    </header>

    <div class="stage">
      <matterport-viewer
        id="mpv"
        m="1ghABoaBFPZ"
        application-key="akqd0dp3hr9wz4eu70zd1rsab"
        asset-base="bundle"
        autoplay
        play>
      </matterport-viewer>

      <div class="hud" id="hud">Idle</div>
    </div>
  </div>

  <script type="module">
    // ----------- Backend resolution (Cloud Run hard-wire + ?api= override)
    const API_PARAM = new URLSearchParams(window.location.search).get("api");
    const HARD_WIRE = "https://ark-safety-1009793361447.us-east1.run.app";
    function resolveBackend() {
      if (API_PARAM) return API_PARAM.replace(/\/+$/, "");
      if (HARD_WIRE) return HARD_WIRE.replace(/\/+$/, "");
      const { protocol, hostname } = window.location;
      return `${protocol}//${hostname}:7860`;
    }
    const BACKEND_URL = resolveBackend();
    window.BACKEND_URL = BACKEND_URL;

    // ------------ UI helpers
    const hud = document.getElementById('hud');
    const statusEl = document.getElementById('status');
    const btnThreat  = document.getElementById('btnPlaceThreat');
    const btnCompute = document.getElementById('btnCompute');
    const btnTruth   = document.getElementById('btnToggleTruth');
    const btnProbe   = document.getElementById('btnProbe');
    const btnReset   = document.getElementById('btnReset');

    const say = (m) => { hud.textContent = m; console.log('[ARK]', m); };
    const setStatus = (html) => { statusEl.innerHTML = html; };

    // In-scene state
    const _ARK = {
      inScene: { available:false, THREE:null, root:null, routeMesh:null },
      camera: null,
      threatWorld: null,
      threatNav:   null,
      backendReady: false,
      truthMode: false,   // NEW: line vs tube
    };

    // --------- Health poll
    async function pollHealth() {
      try {
        const r = await fetch(`${BACKEND_URL}/health`, { cache: 'no-store' });
        const j = await r.json();
        const dot = j.ready ? 'ok' : (j.load?.phase ? 'warm' : 'err');
        const msg = j.ready
          ? `Ready • nodes: ${j.nodes} • walls: ${j.walls}${j.obj_selected ? ` • src: ${String(j.obj_selected).split('/').pop()}`:''}`
          : (j.load?.phase
              ? `Warming • ${j.load.phase}${typeof j.load.percent==='number' ? ` ${j.load.percent}%` : ''}`
              : `Unavailable`);
        setStatus(`<span class="dot ${dot}"></span>${msg}`);
        _ARK.backendReady = !!j.ready;
        const uiUp = _ARK.inScene.available;
        btnCompute.disabled = !(j.ready && uiUp);
        btnTruth.disabled = !(j.ready && uiUp);
        btnProbe.disabled = !(j.ready && uiUp);
        btnThreat.disabled  = !uiUp;
      } catch (e) {
        setStatus(`<span class="dot err"></span>Health error`);
        _ARK.backendReady = false;
        btnCompute.disabled = true;
        btnTruth.disabled = true;
        btnProbe.disabled = true;
      }
    }
    setInterval(pollHealth, 1000);
    pollHealth();

    // --------- Coordinate helpers (nav meters <-> world)
    const ROUTE_Y = 0.10; // 10 cm above floor
    const worldToNav = (p) => ({ x: p.x, y: p.z });
    const navToWorld = (p) => new _ARK.inScene.THREE.Vector3(p.x, ROUTE_Y, p.y);

    // --------- Route renderers
    function clearRoute() {
      if (_ARK.inScene.routeMesh && _ARK.inScene.root) {
        _ARK.inScene.routeMesh.geometry?.dispose?.();
        _ARK.inScene.routeMesh.material?.dispose?.();
        _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
        _ARK.inScene.routeMesh = null;
      }
      // also clear node viz, if any
      if (window._navVizGroup && _ARK.inScene.root) {
        _ARK.inScene.root.remove(window._navVizGroup);
        window._navVizGroup = null;
      }
    }

    function renderRouteTruth(points) {
      const T = _ARK.inScene.THREE, root = _ARK.inScene.root;
      const pts = points.map(p => navToWorld({x:p.x, y:p.y}));
      const g = new T.BufferGeometry().setFromPoints(pts);
      const m = new T.LineBasicMaterial({ linewidth: 3, depthTest: false });
      const line = new T.Line(g, m);
      root.add(line);
      _ARK.inScene.routeMesh = line;
    }

    function renderRoutePretty(points) {
      const T = _ARK.inScene.THREE, root = _ARK.inScene.root;
      const pts = points.map(p => navToWorld({x:p.x, y:p.y}));
      const curve = new T.CatmullRomCurve3(pts, false, "centripetal", 0.35);
      const tubularSegments = Math.max(100, pts.length * 20);
      const geo = new T.TubeGeometry(curve, tubularSegments, 0.06, 12, false);
      const mat = new T.MeshBasicMaterial({ color: 0x22ff88, depthTest: false });
      const mesh = new T.Mesh(geo, mat);
      root.add(mesh);
      _ARK.inScene.routeMesh = mesh;
    }

    function renderRoute3D(points) {
      if (!_ARK.inScene.available) throw new Error("In-scene not available");
      if (!Array.isArray(points) || points.length < 2) throw new Error("renderRoute3D: invalid points");
      clearRoute();
      if (_ARK.truthMode) renderRouteTruth(points);
      else renderRoutePretty(points);
    }

    // --- Tiny nav-node visualizer (Option B)
    async function probeAndRenderNearestVisible(x, y) {
      const url = `${BACKEND_URL}/debug/snap_probe?x=${x}&y=${y}&k=120`;
      const res = await fetch(url, { method: 'POST' });
      const data = await res.json();
      console.log('snap_probe', data);

      // cleanup old markers
      if (window._navVizGroup && _ARK.inScene.root) _ARK.inScene.root.remove(window._navVizGroup);
      const T = _ARK.inScene.THREE;
      const g = new T.Group();
      window._navVizGroup = g; _ARK.inScene.root.add(g);

      // helper to draw a small disk
      function dot(px, py, color, r=0.25) {
        const geom = new T.CircleGeometry(r, 24);
        const mat = new T.MeshBasicMaterial({ color, depthTest: false });
        const m = new T.Mesh(geom, mat);
        m.position.set(px, ROUTE_Y + 0.02, py);
        g.add(m);
      }

      // your probe point
      dot(x, y, 0x0066ff, 0.25); // blue dot at probe

      // draw top candidates (grey = not visible, green = visible)
      for (const c of (data.sample_top || [])) {
        dot(c.xy[0], c.xy[1], c.visible ? 0x00cc66 : 0x888888, 0.18);
      }

      // draw the chosen nearest visible node + a line from probe
      const nv = data.nearest_visible_node;
      if (nv && nv.xy) {
        dot(nv.xy[0], nv.xy[1], 0x00ff00, 0.3); // bright green
        const geom = new T.BufferGeometry().setFromPoints([
          new T.Vector3(x, ROUTE_Y + 0.01, y),
          new T.Vector3(nv.xy[0], ROUTE_Y + 0.01, nv.xy[1]),
        ]);
        const mat = new T.LineBasicMaterial({ color: 0x00ff00, linewidth: 2, depthTest: false });
        g.add(new T.Line(geom, mat));
      }

      // HUD hint
      if (nv?.dist_m != null) {
        say(`Probe: nearest visible nid=${nv.nid}, dist=${nv.dist_m.toFixed(2)} m, mode=${nv.mode || 'none'}`);
      } else {
        say(`Probe: no visible node found (k=${(data.snap_params||{}).k})`);
      }
    }

    // ------------ Buttons
    btnReset.onclick = () => {
      clearRoute();
      _ARK.threatWorld = null;
      _ARK.threatNav = null;
      say('Reset');
    };

    btnTruth.onclick = () => {
      _ARK.truthMode = !_ARK.truthMode;
      btnTruth.textContent = `Truth Mode: ${_ARK.truthMode ? 'On' : 'Off'}`;
      // re-compute to re-render in chosen style
    };

    btnThreat.onclick = () => {
      if (!_ARK.camera?.position) { say("No camera pose yet"); return; }
      const pos = _ARK.camera.position;
      _ARK.threatWorld = { x: pos.x, y: pos.y, z: pos.z };
      _ARK.threatNav   = worldToNav(pos);
      say(`Threat set at camera (nav): (${_ARK.threatNav.x.toFixed(2)}, ${_ARK.threatNav.y.toFixed(2)})`);
    };

    // Probe button: uses threat if set, else current camera nav XY
    btnProbe.onclick = async () => {
      if (!_ARK.inScene.available) { say("In-scene not ready"); return; }
      const src = _ARK.threatNav || (_ARK.camera?.position && worldToNav(_ARK.camera.position));
      if (!src) { say("No camera pose yet"); return; }
      await probeAndRenderNearestVisible(src.x, src.y);
    };

    // ---- Single-flight + timeout to prevent request storms
    let _busy = false;

    btnCompute.onclick = async () => {
      if (_busy) { say('Already computing…'); return; }
      _busy = true;
      try {
        if (!_ARK.inScene.available) throw new Error("In-scene not available");
        if (!_ARK.camera?.position) throw new Error("No camera pose yet");
        if (!_ARK.threatNav) throw new Error("No threat set (click 'Place Threat' first)");
        if (!_ARK.backendReady) throw new Error("Backend not ready yet");

        const startNav  = worldToNav(_ARK.camera.position);
        const threatNav = _ARK.threatNav;

        // 30s client-side cap (server caps internally at 5s)
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), 30000);

        const res = await fetch(`${BACKEND_URL}/route/auto`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            start:  { x: startNav.x,  y: startNav.y  },
            threat: { x: threatNav.x, y: threatNav.y }
          }),
          signal: controller.signal
        }).finally(() => clearTimeout(timer));

        const data = await res.json();
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);

        const pts = Array.isArray(data.route) ? data.route.map(([x,y]) => ({x,y}))
                  : Array.isArray(data.points) ? data.points : null;

        if (!pts || pts.length < 2) throw new Error("Router returned no usable points");
        renderRoute3D(pts);
        say(_ARK.truthMode ? "Route rendered (Truth line)" : "Route rendered (3D)");
      } catch (err) {
        console.error(err);
        say(`Error: ${err.message || err}`);
      } finally {
        _busy = false;
      }
    };

    // ------------ Bootstrap: mount Scene component
    const viewer = document.getElementById('mpv');
    (async () => {
      await customElements.whenDefined('matterport-viewer');
      const mpSdk = await viewer.playingPromise;
      setStatus('<span class="dot warm"></span>SDK connected (WebComponent)');

      const S = mpSdk.Scene;
      if (!S || typeof S.register !== 'function') throw new Error("Scene API not available");

      class ArkRoute {
        constructor() { this.inputs = { enabled: true }; this.outputs = {}; }
        onInit() {
          const T = (this && this.THREE) || window.THREE;
          if (!T) throw new Error("THREE not available from Scene");
          const root = new T.Group();
          this.outputs.objectRoot = root;
          _ARK.inScene = { available:true, THREE:T, root, routeMesh:null };
          say("In-scene component initialized");
          // enable UI once scene is up; compute is additionally gated by backendReady
          btnThreat.disabled = false;
          btnCompute.disabled = !_ARK.backendReady;
          btnTruth.disabled = !_ARK.backendReady;
          btnProbe.disabled = !_ARK.backendReady;
        }
        onTick() {}
        onDestroy() {
          _ARK.inScene.available = false;
          clearRoute();
          _ARK.inScene = { available:false, THREE:null, root:null, routeMesh:null };
          btnThreat.disabled = true; btnCompute.disabled = true; btnTruth.disabled = true; btnProbe.disabled = true;
        }
      }

      await S.register("arkRoute", () => new ArkRoute());
      const node = await S.createNode();
      try { node.addComponent("mp.lights", {}); } catch {}
      node.addComponent("arkRoute", {});
      await node.start();

      try { mpSdk.Camera.pose.subscribe((p) => { _ARK.camera = p; }); }
      catch (err) { console.warn("[ARK] pose.subscribe failed", err); }
    })().catch(err => { console.error("[ARK] bootstrap failed:", err); throw err; });
  </script>
</body>
</html>