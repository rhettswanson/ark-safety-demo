<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Ark SafeRoute — Phase 1.2 (WebComponent)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b0f1a; color:#e5e7eb;}
    .topbar{position:fixed; inset:0 0 auto 0; display:flex; gap:16px; align-items:center; padding:10px 12px; background:rgba(10,14,25,.85); backdrop-filter: blur(6px); border-bottom:1px solid #1f2937; z-index:10}
    .pill{background:#111827; border:1px solid #374151; color:#9ca3af; border-radius:999px; padding:4px 10px; font-size:12px}
    .group{display:flex; align-items:center; gap:10px}
    .btn{cursor:pointer; background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:8px; padding:8px 12px; font-weight:600}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .field{display:flex; align-items:center; gap:6px}
    #stats{margin-left:auto; color:#9ca3af; font-size:13px}
    #stage{position:absolute; inset:48px 0 0 0; background:#000}
    #overlay{position:absolute; inset:48px 0 0 0; pointer-events:none}
    #toast{position:fixed; right:12px; bottom:12px; background:#111827; border:1px solid #374151; color:#e5e7eb; padding:8px 12px; border-radius:8px; font-size:13px; opacity:0; transform:translateY(6px); transition:all .25s}
    #toast.show{opacity:1; transform:translateY(0)}
  </style>

  <!-- WebComponent (SDK Bundle) -->
  <script type="module">
    import 'https://unpkg.com/@matterport/webcomponent?module';
  </script>
</head>
<body>
  <div class="topbar">
    <span class="pill">Phase 1.2</span>
    <div class="group">
      <button class="btn" id="btnPlaceThreat">Place Threat</button>
      <div class="field">
        <label>Mode</label>
        <select id="modeSelect" class="btn" style="padding:6px 10px; background:#0f172a;">
          <option value="auto" selected>Auto (Recommended)</option>
          <option value="evac">Force Evac</option>
          <option value="shelter">Force Shelter</option>
        </select>
      </div>
      <button class="btn" id="btnReset">Reset</button>
    </div>
    <div id="stats">Loading…</div>
  </div>

  <div id="stage">
    <matterport-viewer
      id="mp"
      style="width:100%;height:100%;border:0;display:block"
      m="1ghABoaBFPZ"
      application-key="akqd0dp3hr9wz4eu70zd1rsab"
      asset-base="bundle"
      autoplay
      qs
      play>
    </matterport-viewer>
  </div>

  <!-- Overlay fallback -->
  <canvas id="overlay"></canvas>
  <div id="toast"></div>

  <script type="module">
    // -------------------- Backend --------------------
    const BACKEND_URL = (() => {
      return location.hostname.endsWith('github.io')
        ? 'https://potter-democratic-networking-involves.trycloudflare.com'
        : 'http://localhost:7860';
    })();

    // -------------------- UI helpers --------------------
    const stats = document.getElementById('stats');
    const toastEl = document.getElementById('toast');
    function info(msg){ console.log('[ARK]', msg); stats.textContent = msg; }
    let toastTimer;
    function toast(msg, ms=2200){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toastEl.classList.remove('show'), ms);
    }

    // -------------------- Overlay fallback --------------------
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    function sizeOverlay(){ overlay.width=overlay.clientWidth; overlay.height=overlay.clientHeight; }
    function clearCanvas(){ ctx.clearRect(0,0,overlay.width, overlay.height); }
    function drawRoute(route){
      clearCanvas(); if (!route||route.length<2) return;
      ctx.lineJoin="round"; ctx.lineCap="round";
      // glow
      ctx.lineWidth=14; ctx.strokeStyle="rgba(0,200,130,0.25)";
      ctx.beginPath(); route.forEach(([x,y],i)=>{const [px,py]=[overlay.width/2+x*10,overlay.height/2-y*10]; i?ctx.lineTo(px,py):ctx.moveTo(px,py);}); ctx.stroke();
      // core animated path
      ctx.setLineDash([18,10]); ctx.lineDashOffset=-(performance.now()*0.05);
      ctx.lineWidth=7; ctx.strokeStyle="#00C882";
      ctx.beginPath(); route.forEach(([x,y],i)=>{const [px,py]=[overlay.width/2+x*10,overlay.height/2-y*10]; i?ctx.lineTo(px,py):ctx.moveTo(px,py);}); ctx.stroke(); ctx.setLineDash([]);
    }

    // -------------------- Scene API route injection --------------------
    window._ARK = { 
      inScene:{
        available:false,
        THREE:null,
        root:null,
        routeMesh:null,
      }
    };

    function buildRouteMesh(poly, floorY=0.1){
      const T=_ARK.inScene.THREE; 
      if(!T||!poly||poly.length<2) return null;
      const pts=poly.map(([x,y])=>new T.Vector3(x,floorY,y));
      const curve=new T.CatmullRomCurve3(pts,false,'catmullrom',0.02);
      const tubularSegments=Math.max(40, pts.length*10);
      const radius=0.12;
      const radialSegments=12;
      const geom=new T.TubeGeometry(curve, tubularSegments, radius, radialSegments, false);
      const mat=new T.MeshStandardMaterial({ color:0x00c882, roughness:0.6, metalness:0 });
      mat.emissive=new T.Color(0x00c882); mat.emissiveIntensity=0.35;
      const mesh=new T.Mesh(geom,mat);
      const haloGeom=new T.TubeGeometry(curve, tubularSegments, radius*1.5, 8, false);
      const haloMat=new T.MeshBasicMaterial({ color:0x00c882, transparent:true, opacity:0.15 });
      const halo=new T.Mesh(haloGeom, haloMat);
      const group=new T.Group();
      group.add(mesh); group.add(halo);
      group.renderOrder = 999;
      return group;
    }

    function renderRoute(poly){
      if(_ARK.inScene.available && _ARK.inScene.root){
        if(_ARK.inScene.routeMesh){
          _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
          disposeRoute(_ARK.inScene.routeMesh);
        }
        const group = buildRouteMesh(poly, 0.1);
        if(group){
          _ARK.inScene.root.add(group);
          _ARK.inScene.routeMesh = group;
          clearCanvas();
          return;
        }
      }
      drawRoute(poly);
    }

    function disposeRoute(group){
      const T=_ARK.inScene.THREE;
      if(!group||!T) return;
      group.traverse(obj=>{
        if(obj.geometry){ obj.geometry.dispose?.(); }
        if(obj.material){
          if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose?.());
          else obj.material.dispose?.();
        }
      });
    }

    function resetRoute(){
      if(_ARK.inScene.routeMesh && _ARK.inScene.root){
        _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
        disposeRoute(_ARK.inScene.routeMesh);
      }
      _ARK.inScene.routeMesh=null; 
      clearCanvas(); 
      window._lastRoute=null;
      threat=null; 
      pendingRoute=false;
      stats.textContent = 'Ready';
    }

    // -------------------- App logic --------------------
    let _sdk=null; 
    let threat=null;
    let pendingRoute=false;
    let unsubPointer=null;

    async function ensureInside(){
      try{
        await _sdk.Mode.set({ 
          mode: _sdk.Mode.Mode.inside, 
          transition: _sdk.Mode.TransitionType.instant 
        });
      }catch(_){}
    }

    async function isGroundable(){
      try{
        const rect=overlay.getBoundingClientRect();
        const hit=await _sdk.Renderer.getWorldPositionData({x:rect.width/2,y:rect.height/2});
        return !!(hit&&hit.normal&&hit.normal.y>0.7);
      }catch{
        return false;
      }
    }

    async function routeSafeAuto(){
      if(!await isGroundable()){ toast("Move inside first"); return; }
      if(!threat){ toast("Place a threat"); return; }
      const pos=await _sdk.Camera.getPosition(); 
      const cam={x:pos.x,y:pos.z};
      const mode=(document.getElementById("modeSelect")?.value||"auto").toLowerCase();
      const url = mode==="auto" ? `${BACKEND_URL}/route/auto` : `${BACKEND_URL}/route_safe`;
      const body= mode==="auto" ? {start:cam,threat} : {start:cam,threat,prefer:mode==="evac"?"exit":"shelter"};
      const res=await fetch(url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(body)});
      if(!res.ok){ toast(`Route error ${res.status}`); return; }
      const out=await res.json();
      window._lastRoute=out.route;
      stats.textContent=`Length: ${out.length_m?.toFixed(1)} m · ${out.mode_selected||out.decision||"—"}`;
      renderRoute(out.route);
    }

    function disarmPointer(){
      if (typeof unsubPointer === 'function') { unsubPointer(); }
      unsubPointer=null;
      document.body.style.cursor='default';
    }
    function armPointerOnce(){
      document.body.style.cursor='crosshair';
      unsubPointer = _sdk.Pointer.intersection.subscribe(async (ev)=>{
        disarmPointer();
        try{
          const hit = await _sdk.Renderer.getWorldPositionData({ x: ev.clientX, y: ev.clientY });
          if(hit?.position&&hit.normal?.y>0.4){
            threat={x:hit.position.x,y:hit.position.z};
            pendingRoute=true;
            toast("Threat placed. Routing will start once viewer is inside.");
            maybeTryRoute();
          }else{
            toast("Not a floor hit");
          }
        }catch(err){
          toast("Placement failed");
          console.warn('[ARK] placement error', err);
        }
      });
    }

    async function maybeTryRoute(){
      if (!pendingRoute || !threat) return;
      if (!await isGroundable()) return;
      pendingRoute=false;
      routeSafeAuto();
    }

    async function enableThreatPlacement(){
      await ensureInside();
      toast("Click in scene to place threat");
      armPointerOnce();
    }

    document.getElementById('btnPlaceThreat').addEventListener('click', enableThreatPlacement);
    document.getElementById('btnReset').addEventListener('click', resetRoute);

    // -------------------- SDK bootstrap --------------------
    customElements.whenDefined('matterport-viewer').then(()=>{
      const el=document.getElementById('mp');
      el.addEventListener('mpSdkPlaying', async (e)=>{
        _sdk=e.detail.mpSdk; 
        info("SDK connected (WebComponent)");

        // One-time assert: log Scene keys so you can confirm exposure
        try {
          const sceneKeys = Object.keys(_sdk.Scene || {});
          console.log('[ARK] Scene keys:', sceneKeys);
        } catch (err) {
          console.warn('[ARK] Could not log Scene keys', err);
        }

        // Enable Scene API via node/component flow (your build)
        const S = _sdk.Scene;
        if (S && typeof S.register === 'function' && typeof S.createNode === 'function') {
          class ArkRoute {
            onInit(ctx){
              const T = ctx.THREE || ctx.three;
              this.outputs = this.outputs || {};
              const root = new T.Group();
              this.outputs.objectRoot = root;

              try { console.log('[ARK] THREE revision:', T && T.REVISION); } catch {}

              _ARK.inScene.available = true;
              _ARK.inScene.THREE = T;
              _ARK.inScene.root = root;

              console.log("[ARK] In-scene route root created");
            }
            onTick() {}
            onDestroy() {
              _ARK.inScene.available = false;
              _ARK.inScene.root = null;
              _ARK.inScene.THREE = null;
              _ARK.inScene.routeMesh = null;
            }
          }
          S.register('arkRoute', () => new ArkRoute());
          const node = await S.createNode();
          node.addComponent('arkRoute');
          await node.start();
        } else {
          console.warn('[ARK] Scene API not available; overlay fallback in use.');
          _ARK.inScene.available=false;
        }

        // Overlay glue + opportunistic routing when pose stabilizes
        try{ 
          _sdk.Camera.pose.subscribe(async ()=>{
            if (window._lastRoute && !_ARK.inScene.available) drawRoute(window._lastRoute);
            maybeTryRoute();
          }); 
        }catch{}
      },{once:true});
    });

    sizeOverlay();
    window.addEventListener('resize', sizeOverlay);
  </script>
</body>
</html>