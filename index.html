<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Ark SafeRoute — Phase 1.2</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b0f1a; color:#e5e7eb;}
    .topbar{position:fixed; inset:0 0 auto 0; display:flex; gap:16px; align-items:center; padding:10px 12px; background:rgba(10,14,25,.85); backdrop-filter: blur(6px); border-bottom:1px solid #1f2937; z-index:10}
    .pill{background:#111827; border:1px solid #374151; color:#9ca3af; border-radius:999px; padding:4px 10px; font-size:12px}
    .group{display:flex; align-items:center; gap:10px}
    .btn{cursor:pointer; background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:8px; padding:8px 12px; font-weight:600}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .field{display:flex; align-items:center; gap:6px}
    #stats{margin-left:auto; color:#9ca3af; font-size:13px}
    #stage{position:absolute; inset:48px 0 0 0; background:#000}
    #overlay{position:absolute; inset:48px 0 0 0; pointer-events:none}
    #toast{position:fixed; right:12px; bottom:12px; background:#111827; border:1px solid #374151; color:#e5e7eb; padding:8px 12px; border-radius:8px; font-size:13px; opacity:0; transform:translateY(6px); transition:all .25s}
    #toast.show{opacity:1; transform:translateY(0)}
  </style>
</head>
<body>
  <div class="topbar">
    <span class="pill">Phase 1.2</span>
    <div class="group">
      <button class="btn" id="btnPlaceThreat">Place Threat</button>
      <div class="field">
        <label>Mode</label>
        <select id="modeSelect" class="btn" style="padding:6px 10px; background:#0f172a;">
          <option value="auto" selected>Auto (Recommended)</option>
          <option value="evac">Force Evac</option>
          <option value="shelter">Force Shelter</option>
        </select>
      </div>
      <button class="btn" id="btnReset">Reset</button>
    </div>
    <div id="stats">Ready</div>
  </div>

  <!-- Your viewer goes under #stage; we’ll allow either iframe or existing setup -->
  <div id="stage">
    <!-- Optional fallback iframe (only used if you don’t already create Showcase elsewhere) -->
    <iframe id="showcase" style="width:100%;height:100%;border:0;display:none"></iframe>
  </div>
  <canvas id="overlay"></canvas>
  <div id="toast"></div>

  <script>
    /**********************
     * Config
     **********************/
    const MODEL  = "1ghABoaBFPZ";
    const APPKEY = "akqd0dp3hr9wz4eu70zd1rsab";
    const BUNDLE_PATH = "bundle/dist/showcase.html";
    const BACKEND_URL = "https://bed-drums-vermont-dodge.trycloudflare.com";

    /**********************
     * Simple log + toast
     **********************/
    const stats = document.getElementById('stats');
    const toastEl = document.getElementById('toast');
    function info(msg){ console.log('[ARK]',msg); stats.textContent = msg; }
    let toastTimer;
    function toast(msg, ms=2000){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toastEl.classList.remove('show'), ms);
    }

    /**********************
     * Overlay canvas (fallback)
     **********************/
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    let SITE_BBOX = null; // {min:[x,y], max:[x,y]} for bbox→canvas mapping
    function resize(){
      overlay.width = overlay.clientWidth;
      overlay.height = overlay.clientHeight;
      if (window._lastRoute) drawRoute(window._lastRoute);
    }
    window.addEventListener('resize', resize);
    function clearCanvas(){ ctx.clearRect(0,0,overlay.width, overlay.height); }
    function fitFromBBox(){
      // nothing to do; worldToCanvas uses bbox
      if (window._lastRoute) drawRoute(window._lastRoute);
    }
    function worldToCanvas(x,y){
      if (!SITE_BBOX){
        // Identity fallback: center the scene
        return [overlay.width/2 + x*10, overlay.height/2 - y*10];
      }
      const [minX,minY] = SITE_BBOX.min;
      const [maxX,maxY] = SITE_BBOX.max;
      const w = maxX - minX, h = maxY - minY;
      const pad = 40;
      const sx = (overlay.width  - 2*pad) / (w || 1);
      const sy = (overlay.height - 2*pad) / (h || 1);
      const s = Math.min(sx, sy);
      const px = pad + (x - minX) * s;
      const py = overlay.height - (pad + (y - minY) * s);
      return [px, py];
    }
    function drawRoute(route){
      clearCanvas();
      if (!route || route.length < 2) return;

      const t = performance.now() * 0.05;

      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      // Outer glow
      ctx.lineWidth = 14;
      ctx.strokeStyle = "rgba(0, 200, 130, 0.25)";
      ctx.beginPath();
      route.forEach((p,i)=>{
        const [px,py] = worldToCanvas(p[0], p[1]);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      });
      ctx.stroke();

      // Core path (animated dash)
      ctx.setLineDash([18, 10]);
      ctx.lineDashOffset = -(performance.now()*0.05);
      ctx.lineWidth = 7;
      ctx.strokeStyle = "#00C882";
      ctx.beginPath();
      route.forEach((p,i)=>{
        const [px,py] = worldToCanvas(p[0], p[1]);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      });
      ctx.stroke();
      ctx.setLineDash([]);

      // Start/End markers
      const endpoints = [
        {p:route[0], color:"#3b82f6", label:"Start"},
        {p:route[route.length-1], color:"#10b981", label:"Safe Point"}
      ];
      ctx.font = "12px system-ui";
      endpoints.forEach(({p,color,label})=>{
        const [px,py] = worldToCanvas(p[0], p[1]);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(label, px+8, py-8);
      });
    }

    /**********************
     * Matterport SDK hookup
     **********************/
    let _sdk = null;
    let pendingRouteWhenInside = false;
    let threat = null;

    // If your project already defines connectShowcase(), we'll use it.
    async function connectShowcaseFallback(){
      const iframe = document.getElementById('showcase');
      if (!iframe || !MODEL_ID || !SDK_KEY) {
        console.warn('No iframe fallback. Provide MODEL_ID and MP_SDK_KEY, or ensure connectShowcase() exists.');
        return null;
      }
      iframe.style.display = 'block';
      const url = new URL('https://my.matterport.com/show/');
      url.searchParams.set('m', MODEL_ID);
      url.searchParams.set('play', '1');
      url.searchParams.set('qs', '1');
      iframe.src = url.toString();
      return await window.MP_SDK.connect(iframe, SDK_KEY, SDK_VERSION);
    }

    async function getSdk(){
      if (typeof window.connectShowcase === 'function'){
        const sdk = await window.connectShowcase();
        return sdk;
      }
      return await connectShowcaseFallback();
    }

    // Grounding check
    async function isGroundableAtCenter(){
      try{
        const rect = overlay.getBoundingClientRect();
        const x = rect.width/2, y = rect.height/2;
        const hit = await _sdk.Renderer.getWorldPositionData({ x, y });
        // Require a reasonably "floor-like" normal
        return !!(hit && hit.normal && hit.normal.y > 0.7);
      }catch(e){
        return false;
      }
    }

    // In-scene mesh helpers (TubeGeometry) with overlay fallback
    window._ARK = window._ARK || {};
    _ARK.inScene = { available:false, scene:null, THREE:null, routeMesh:null };

    function routeMeshFromPolyline(poly, floorY=0.1){
      const THREE = _ARK.inScene.THREE;
      if (!THREE || !Array.isArray(poly) || poly.length < 2) return null;
      const pts = poly.map(([x,y]) => new THREE.Vector3(x, floorY, y));
      const curve = new THREE.CatmullRomCurve3(pts, false, 'catmullrom', 0.02);
      const tubularSegments = Math.max(40, Math.floor(pts.length * 10));
      const geom = new THREE.TubeGeometry(curve, tubularSegments, 0.12, 8, false);
      const mat  = new THREE.MeshStandardMaterial({ color: 0x00c882, metalness:0, roughness:.6 });
      mat.emissive = new (_ARK.inScene.THREE.Color)(0x00c882);
      mat.emissiveIntensity = 0.35;
      const mesh = new (_ARK.inScene.THREE.Mesh)(geom, mat);
      mesh.name = 'ARK_ROUTE_MESH';
      return mesh;
    }
    _ARK.addRouteInScene = (poly) => {
      if (!_ARK.inScene.available || !_ARK.inScene.scene) return false;
      if (_ARK.inScene.routeMesh){
        _ARK.inScene.scene.remove(_ARK.inScene.routeMesh);
        _ARK.inScene.routeMesh.geometry.dispose();
        _ARK.inScene.routeMesh.material.dispose();
        _ARK.inScene.routeMesh = null;
      }
      const mesh = routeMeshFromPolyline(poly, 0.10);
      if (!mesh) return false;
      _ARK.inScene.scene.add(mesh);
      _ARK.inScene.routeMesh = mesh;
      return true;
    };
    _ARK.clearRouteInScene = () => {
      if (_ARK.inScene.routeMesh && _ARK.inScene.scene){
        _ARK.inScene.scene.remove(_ARK.inScene.routeMesh);
        _ARK.inScene.routeMesh.geometry.dispose();
        _ARK.inScene.routeMesh.material.dispose();
        _ARK.inScene.routeMesh = null;
      }
    };

    // Public draw wrappers
    function renderRoute(poly){
      // Try in-scene first; fallback to overlay
      if (!_ARK.addRouteInScene(poly)){
        drawRoute(poly);
      } else {
        clearCanvas();
      }
    }
    function resetRoute(){
      _ARK.clearRouteInScene();
      clearCanvas();
      window._lastRoute = null;
    }

    // Route main
    async function routeSafeAuto(){
      const ok = await isGroundableAtCenter();
      if (!ok) {
        pendingRouteWhenInside = true;
        toast("Move inside to compute safest route");
        info("Deferred: move inside to compute route");
        return;
      }
      if (!threat) { toast("Place a threat pin first."); return; }

      // camera center (x,z) in world meters
      let cam = {x:0,y:0};
      try {
        const pos = await _sdk.Camera.getPosition();
        cam = { x: pos.x, y: pos.z };
      } catch {
        // Optional fallback (e.g., manual)
      }

      const mode = (document.getElementById("modeSelect")?.value || "auto").toLowerCase();

      info("Routing...");
      try{
        let res;
        if (mode === "auto") {
          res = await fetch(`${BACKEND_URL}/route/auto`, {
            method:"POST", headers:{"Content-Type":"application/json"},
            body: JSON.stringify({ start:cam, threat })
          });
        } else {
          res = await fetch(`${BACKEND_URL}/route_safe`, {
            method:"POST", headers:{"Content-Type":"application/json"},
            body: JSON.stringify({ start:cam, threat, prefer: mode === "evac" ? "exit" : "shelter" })
          });
        }
        if(!res.ok){
          const txt = await res.text();
          throw new Error(`Route error ${res.status}: ${txt}`);
        }
        const out = await res.json();

        if (!SITE_BBOX && out.route?.length >= 2) {
          const xs = out.route.map(p=>p[0]);
          const ys = out.route.map(p=>p[1]);
          SITE_BBOX = { min: [Math.min(...xs), Math.min(...ys)], max: [Math.max(...xs), Math.max(...ys)] };
          fitFromBBox();
        }

        window._lastRoute = out.route;
        const decision = out.mode_selected || out.decision || "—";
        stats.textContent = `Length: ${out.length_m?.toFixed(1)} m · ${decision}`;
        renderRoute(out.route);
      }catch(e){
        console.error(e);
        toast(e.message || "Route failed");
      }
    }

    // Threat placement
    function enableThreatPlacement(){
      toast("Click on the scene to place threat");
      // Here we assume clicks feed us screen coords → world hit
      window.addEventListener('click', onClickOnce, { once:true });
      async function onClickOnce(ev){
        try{
          const x = ev.clientX, y = ev.clientY;
          const hit = await _sdk.Renderer.getWorldPositionData({x, y});
          if (hit?.position){
            if (hit.normal?.y > 0.4){
              threat = { x: hit.position.x, y: hit.position.z };
              toast(`Threat placed at (${threat.x.toFixed(2)}, ${threat.y.toFixed(2)})`);
              routeSafeAuto();
            } else {
              toast("Not a floor hit; try again inside.");
            }
          }
        }catch(e){
          toast("Could not place threat here");
        }
      }
    }

    // UI wiring
    document.getElementById('btnPlaceThreat').addEventListener('click', enableThreatPlacement);
    document.getElementById('btnReset').addEventListener('click', resetRoute);

    // Boot
    (async function boot(){
      // Fit overlay canvas to stage
      function syncOverlayRect(){
        const stage = document.getElementById('stage');
        overlay.style.left = stage.style.left;
        overlay.style.top = stage.style.top;
        overlay.style.width = stage.clientWidth + 'px';
        overlay.style.height= stage.clientHeight + 'px';
        overlay.width  = stage.clientWidth;
        overlay.height = stage.clientHeight;
      }
      syncOverlayRect();
      window.addEventListener('resize', syncOverlayRect);

      _sdk = await getSdk();
      if (!_sdk){ info('SDK not connected'); return; }
      info('SDK connected');

      // Pose redraw to prevent overlay drift (fallback path)
      try {
        _sdk.Camera.pose.subscribe(()=>{ if (window._lastRoute) drawRoute(window._lastRoute); });
      } catch {}

      // Try to expose in-scene render context
      try{
        if (_sdk.Renderer?.getRenderContext){
          const ctx = await _sdk.Renderer.getRenderContext();
          if (ctx?.scene){
            _ARK.inScene.available = true;
            _ARK.inScene.scene = ctx.scene;
            _ARK.inScene.THREE = ctx.THREE || window.THREE || (window.top && window.top.THREE);
            console.log('[ARK] In-scene route enabled');
          }
        }
      }catch(e){
        console.warn('[ARK] No renderContext; overlay fallback in use.');
      }

      // If user armed a route outside, compute once inside
      try {
        _sdk.Camera.pose.subscribe(async ()=>{
          if (pendingRouteWhenInside){
            const ok = await isGroundableAtCenter();
            if (ok){
              pendingRouteWhenInside = false;
              routeSafeAuto();
            }
          }
        });
      } catch {}
    })();

    // Initial size
    resize();
  </script>
</body>
</html>