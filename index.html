<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ARK Safety Demo (WebComponent + Scene API)</title>

  <!-- Three.js import shim (prevents version clashes with Showcase) -->
  <script type="importmap">
  {
    "imports": {
      "three": "./three-shim.js",
      "https://unpkg.com/three@%5E0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@^0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0/build/three.module.js?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0/build/three.module.js": "./three-shim.js"
    }
  }
  </script>

  <script type="module" src="https://unpkg.com/@matterport/webcomponent@0.1.45/dist/matterport-viewer.esm.js?module"></script>

  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e8edf2; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { display: flex; gap: .5rem; align-items: center; padding: .75rem 1rem; background: #11161d; border-bottom: 1px solid #1f2a37; }
    header .tag { font-weight: 600; opacity: .85; }
    header button { all: unset; background: #1f2a37; padding: .45rem .7rem; border-radius: .5rem; cursor: pointer; border: 1px solid #2b3949; }
    header button:hover { background:#243244; }
    header button:active { background:#1b2633; }
    header .spacer { flex: 1 1 auto; opacity:.6; font-size:.9rem; }

    .stage { position: relative; height: 100%; overflow: hidden; background: #000; }
    matterport-viewer { position: absolute; inset: 0; width: 100%; height: 100%; }
    .hud { position: absolute; left: 12px; bottom: 12px; background: rgba(9,12,17,.72); border: 1px solid rgba(64,86,110,.55); padding: .35rem .6rem; border-radius: .5rem; font-size: .85rem; user-select: none; z-index: 10040; }

    /* Annotator panel */
    .annot { position: absolute; top: 0; right: 0; width: 420px; height: 100%;
             background: rgba(15,20,27,.96); border-left: 1px solid #263447;
             display: none; flex-direction: column; z-index: 10050; }
    .annot.show { display: flex; }
    .annot .head { display:grid; grid-template-columns: 1fr 120px auto auto; gap:.5rem;
                   align-items:center; padding:.6rem .8rem; border-bottom:1px solid #223042; }
    .annot .head .title { font-weight:600; grid-column: 1 / 5; }
    .annot .head input[type="text"] { background:#0f1520; color:#e8edf2; border:1px solid #2b3949; border-radius:.45rem; padding:.35rem .5rem; }
    .annot .head input[type="number"] { background:#0f1520; color:#e8edf2; border:1px solid #2b3949; border-radius:.45rem; padding:.35rem .5rem; width: 120px; }
    .annot .head button { all:unset; background:#1f2a37; border:1px solid #2b3949; padding:.3rem .6rem; border-radius:.45rem; cursor:pointer; }
    .annot .head button:hover { background:#243244; }

    .annot .body { overflow:auto; padding:.6rem; display:flex; gap:.6rem; flex-direction:column; }
    .annot .row { display:grid; grid-template-columns: 78px 1fr auto auto; gap:.4rem; align-items:center; padding:.35rem .4rem; border:1px solid #223042; border-radius:.5rem; background:#0d131c; }
    .annot .row .type { width: 100%; }
    .annot .row .lbl { width: 100%; }
    .annot .row .meta { font-size:.8rem; opacity:.75; text-align:right; }
    .annot .row button { all:unset; background:#1f2a37; border:1px solid #2b3949; padding:.3rem .45rem; border-radius:.45rem; cursor:pointer; }
    .annot .foot { margin-top:auto; padding:.6rem; border-top:1px solid #223042; display:flex; gap:.5rem; }
    .pill { font-size:.8rem; opacity:.7; }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <span class="tag">ARK</span>
      <button id="btnPlaceThreat">Place Threat</button>
      <button id="btnCompute">Compute Route</button>
      <button id="btnReset">Reset</button>
      <span class="spacer" id="status">Loading…</span>
      <button id="btnAnnotate">Annotate</button>
    </header>

    <div class="stage">
      <matterport-viewer
        id="mpv"
        m="1ghABoaBFPZ"
        application-key="akqd0dp3hr9wz4eu70zd1rsab"
        asset-base="bundle"
        autoplay
        play>
      </matterport-viewer>

      <div class="hud" id="hud">Idle</div>

      <!-- Annotator Panel -->
      <div id="annot" class="annot">
        <div class="head">
          <div class="title">Annotate Doors</div>
          <input id="annotFilter" type="text" placeholder="filter by label/id" />
          <input id="annotConfMin" type="number" step="0.01" min="0" max="1" value="0" title="min confidence (0..1)" />
          <button id="annotAuto">Auto meta</button>
          <div style="display:flex; gap:.4rem; justify-self:end;">
            <button id="annotSave">Save</button>
            <button id="annotClose">Close</button>
          </div>
        </div>

        <div id="annotBody" class="body"></div>

        <div class="foot">
          <span class="pill">Tip: click “Show” to flash pin in scene</span>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ------------ Backend resolution
    const params = new URLSearchParams(window.location.search);
    const API_PARAM = params.get("api");
    // Default to your Cloudflare tunnel (override anytime with ?api=...)
    const HARD_WIRE = "https://ta-link-insured-refused.trycloudflare.com";
    function resolveBackend() {
      if (API_PARAM) return API_PARAM.replace(/\/+$/,'');
      if (HARD_WIRE) return HARD_WIRE.replace(/\/+$/,'');
      const { protocol, hostname } = window.location;
      if (!/github\.io$/i.test(hostname)) return `${protocol}//${hostname}:7860`;
      console.warn("[ARK] Backend needs an https tunnel on github.io. Use ?api=https://<your-tunnel>/");
      return `${protocol}//${hostname}`;
    }
    const BACKEND_URL = resolveBackend();
    window.BACKEND_URL = BACKEND_URL;

    // ------------ UI helpers
    const hud = document.getElementById('hud');
    const statusEl = document.getElementById('status');
    const say = (m) => { hud.textContent = m; console.log('[ARK]', m); };
    const status = (m) => { statusEl.textContent = m; };

    // In-scene state
    const _ARK = {
      inScene: { available:false, THREE:null, root:null, routeMesh:null, pinsRoot:null },
      camera: null,
      threatWorld: null,
      threatNav:   null,
      meta: null,
      annot: [],         // {id,label,x,y,type, conf?, width_m?}
    };

    // --------- Coordinate helpers (nav meters -> world)
    const ROUTE_Y = 0.10; // 10 cm above floor
    const worldToNav = (p) => ({ x: p.x, y: p.z });
    function v3(x,y,z) { const T = _ARK.inScene.THREE; return new T.Vector3(x,y,z); }
    function navToWorld(p) { return v3(p.x, ROUTE_Y, p.y); }

    // --------- Route (Tube)
    function renderRoute3D(points) {
      if (!_ARK.inScene.available) throw new Error("In-scene not available");
      const T = _ARK.inScene.THREE;
      const root = _ARK.inScene.root;

      if (_ARK.inScene.routeMesh) {
        _ARK.inScene.routeMesh.geometry?.dispose?.();
        _ARK.inScene.routeMesh.material?.dispose?.();
        root.remove(_ARK.inScene.routeMesh);
        _ARK.inScene.routeMesh = null;
      }
      if (!Array.isArray(points) || points.length < 2) throw new Error("renderRoute3D: invalid points");

      const pts = points.map(p => navToWorld({x:p.x, y:p.y}));
      const curve = new T.CatmullRomCurve3(pts, false, "centripetal", 0.35);
      const tubularSegments = Math.max(100, pts.length * 20);
      const radius = 0.06, radialSegments = 12;
      const geo = new T.TubeGeometry(curve, tubularSegments, radius, radialSegments, false);
      const mat = new T.MeshBasicMaterial({ color: 0x22ff88, depthTest: false, transparent: false });
      const mesh = new T.Mesh(geo, mat);
      root.add(mesh);
      _ARK.inScene.routeMesh = mesh;
    }

    // --------- Door Pins for Annotator
    function ensurePinsRoot() {
      const T = _ARK.inScene.THREE;
      if (!_ARK.inScene.pinsRoot) {
        _ARK.inScene.pinsRoot = new T.Group();
        _ARK.inScene.root.add(_ARK.inScene.pinsRoot);
      }
    }
    function clearPins() {
      const root = _ARK.inScene.pinsRoot;
      if (!root) return;
      while (root.children.length) {
        const c = root.children.pop();
        c.geometry?.dispose?.(); c.material?.dispose?.();
      }
    }
    function colorForType(type) {
      if (type === "exit")    return 0x2ee06e;
      if (type === "shelter") return 0x5ea7ff;
      return 0xcccccc; // gray for unlabeled
    }
    function buildPins() {
      if (!_ARK.inScene.available || !_ARK.annot.length) return;
      ensurePinsRoot(); clearPins();

      const T = _ARK.inScene.THREE;
      const root = _ARK.inScene.pinsRoot;

      const confMin = parseFloat(document.getElementById('annotConfMin').value || "0") || 0;

      for (let i = 0; i < _ARK.annot.length; i++) {
        const rec = _ARK.annot[i];
        if (rec.confidence != null && rec.confidence < confMin) continue;
        const mat = new T.MeshBasicMaterial({ color: colorForType(rec.type), depthTest:false });
        const geo = new T.SphereGeometry(0.08, 16, 12);
        const m = new T.Mesh(geo, mat);
        m.position.copy(navToWorld({x:rec.x, y:rec.y}));
        m.userData.recIndex = i;
        root.add(m);
      }
    }
    function flashPin(i) {
      const root = _ARK.inScene.pinsRoot; if (!root) return;
      const m = root.children.find(c => c.userData.recIndex === i);
      if (!m) return;
      const orig = m.material.color.getHex();
      m.material.color.setHex(0xff3366);
      setTimeout(() => m.material.color.setHex(orig), 900);
    }
    function updatePinColor(i) {
      const root = _ARK.inScene.pinsRoot; if (!root) return;
      const m = root.children.find(c => c.userData.recIndex === i);
      if (m) m.material.color.setHex(colorForType(_ARK.annot[i].type));
    }

    // --------- Annotator UI
    const annot = document.getElementById('annot');
    const annotBody = document.getElementById('annotBody');
    const annotFilter = document.getElementById('annotFilter');
    const annotConfMin = document.getElementById('annotConfMin');
    const annotAutoBtn = document.getElementById('annotAuto');

    // Start with only labeled items (exits/shelters) to avoid stray pins.
    async function openAnnotator() {
      const meta = await (await fetch(`${BACKEND_URL}/site/meta`)).json();
      _ARK.meta = meta;

      _ARK.annot = [];
      for (const ex of (meta.exits || []))    _ARK.annot.push({ id: ex.id, label: ex.label, x: ex.x, y: ex.y, type: 'exit' });
      for (const sh of (meta.shelters || [])) _ARK.annot.push({ id: sh.id, label: sh.label, x: sh.x, y: sh.y, type: 'shelter' });

      renderAnnotList();

      // Auto-merge from backend doors_auto feed
      try { await loadAutoMeta(true); } catch {}
      buildPins();

      annot.classList.add('show');
    }

    function renderAnnotList() {
      const q = (annotFilter.value || "").toLowerCase().trim();
      const confMin = parseFloat(annotConfMin.value || "0") || 0;

      annotBody.innerHTML = "";
      _ARK.annot.forEach((rec, i) => {
        if (rec.confidence != null && rec.confidence < confMin) return;
        if (q && !(rec.id?.toLowerCase().includes(q) || rec.label?.toLowerCase().includes(q))) return;

        const row = document.createElement('div');
        row.className = 'row';

        const sel = document.createElement('select');
        sel.className = 'type';
        sel.innerHTML = `
          <option value="">None</option>
          <option value="exit">Exit</option>
          <option value="shelter">Shelter</option>`;
        sel.value = rec.type || "";
        sel.onchange = () => { rec.type = sel.value; updatePinColor(i); };

        const lab = document.createElement('input');
        lab.className = 'lbl';
        lab.placeholder = 'Label (e.g., Exit for Room 203)';
        lab.value = rec.label || "";
        lab.oninput = () => rec.label = lab.value;

        const show = document.createElement('button');
        show.textContent = 'Show';
        show.onclick = () => flashPin(i);

        const meta = document.createElement('div');
        meta.className = 'meta';
        if (rec.width_m != null || rec.confidence != null) {
          const inch = rec.width_m != null ? Math.round(rec.width_m * 39.37) : null;
          const conf = rec.confidence != null ? rec.confidence.toFixed(2) : null;
          meta.textContent = `${inch ? `${inch}"` : ''}${inch && conf ? ' · ' : ''}${conf ? `conf ${conf}` : ''}`;
        } else {
          meta.textContent = '';
        }

        row.appendChild(sel);
        row.appendChild(lab);
        row.appendChild(meta);
        row.appendChild(show);
        annotBody.appendChild(row);
      });
    }

    annotFilter.addEventListener('input', () => { renderAnnotList(); buildPins(); });
    annotConfMin.addEventListener('input', () => { renderAnnotList(); buildPins(); });
    document.getElementById('annotClose').onclick = () => annot.classList.remove('show');

    document.getElementById('annotSave').onclick = async () => {
      const exits    = _ARK.annot.filter(r => r.type === "exit").map(({id,label,x,y}) => ({id,label,x,y}));
      const shelters = _ARK.annot.filter(r => r.type === "shelter").map(({id,label,x,y}) => ({id,label,x,y}));
      const res = await fetch(`${BACKEND_URL}/admin/save_destinations`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ exits, shelters })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data?.error || "Save failed");
      say(`Saved: ${data.exits} exits, ${data.shelters} shelters`);
      annot.classList.remove('show');
    };

    // ---- Auto meta: fetch from backend (/site/doors_auto)
    async function loadAutoMeta(silent=false) {
      const resp = await fetch(`${BACKEND_URL}/site/doors_auto`);
      const j = await resp.json();
      const src = Array.isArray(j) ? j : (j.doors || []);
      let merged = 0, added = 0;

      // nearest-neighbor merge (<= 0.8 m)
      const R = 0.8;
      function nnIdx(x,y){
        let best=-1, bd=R+1;
        for (let i=0;i<_ARK.annot.length;i++){
          const dx=_ARK.annot[i].x-x, dy=_ARK.annot[i].y-y;
          const d=Math.hypot(dx,dy);
          if (d<bd){ bd=d; best=i; }
        }
        return bd<=R ? best : -1;
      }

      for (const d of src) {
        const p = d.pos || d.pos_nav || d.nav || d.xy;
        if (!p || p.length<2) continue;
        const x = +p[0], y = +p[1];
        const i = nnIdx(x,y);

        const width_m   = d.width_m ?? d.width ?? null;
        const confidence = d.confidence ?? d.conf ?? d.score ?? null;

        if (i >= 0) {
          if (width_m != null)   _ARK.annot[i].width_m = +width_m;
          if (confidence != null) _ARK.annot[i].confidence = +confidence;
          if (!_ARK.annot[i].label && width_m != null) {
            const inches = Math.round(+width_m * 39.37);
            _ARK.annot[i].label = `Door (${inches}")`;
          }
          merged++;
        } else {
          // No nearby labeled item -> add as candidate (gray)
          const inches = width_m != null ? Math.round(+width_m * 39.37) : null;
          _ARK.annot.push({
            id: `cand_${Date.now()}_${added}`,
            label: inches ? `Door (${inches}")` : '',
            x, y,
            type: '',
            width_m: width_m ?? undefined,
            confidence: confidence ?? undefined
          });
          added++;
        }
      }

      if (!silent) say(`Auto meta: ${merged} merged, ${added} added`);
      renderAnnotList();
      buildPins();
    }
    annotAutoBtn.addEventListener('click', () => loadAutoMeta(false).catch(console.error));

    // ------------ Buttons
    document.getElementById('btnReset').addEventListener('click', () => {
      if (_ARK.inScene.routeMesh && _ARK.inScene.root) {
        _ARK.inScene.routeMesh.geometry?.dispose?.();
        _ARK.inScene.routeMesh.material?.dispose?.();
        _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
        _ARK.inScene.routeMesh = null;
      }
      _ARK.threatWorld = null;
      _ARK.threatNav = null;
      say('Reset');
    });

    document.getElementById('btnPlaceThreat').addEventListener('click', () => {
      if (!_ARK.camera?.position) { say("No camera pose yet"); return; }
      const pos = _ARK.camera.position;
      _ARK.threatWorld = { x: pos.x, y: pos.y, z: pos.z };
      _ARK.threatNav   = worldToNav(pos);
      say(`Threat set at camera (nav): (${_ARK.threatNav.x.toFixed(2)}, ${_ARK.threatNav.y.toFixed(2)})`);
    });

    document.getElementById('btnCompute').addEventListener('click', async () => {
      try {
        if (!_ARK.inScene.available) throw new Error("In-scene not available");
        if (!_ARK.camera?.position) throw new Error("No camera pose yet");
        if (!_ARK.threatNav) throw new Error("No threat set (click 'Place Threat' first)");

        const startNav = worldToNav(_ARK.camera.position);
        const threatNav = _ARK.threatNav;

        const res = await fetch(`${BACKEND_URL}/route/auto`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            start:  { x: startNav.x,  y: startNav.y  },
            threat: { x: threatNav.x, y: threatNav.y },
            k: 3, dx: 1.5,
            weights: { alpha: 1.0, beta: 12.0, gamma: 2.0, delta: 0.0 }
          })
        });

        const data = await res.json();
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);

        const pts = Array.isArray(data.route) ? data.route.map(([x,y]) => ({ x, y }))
                  : Array.isArray(data.points) ? data.points
                  : null;

        if (!pts || pts.length < 2) throw new Error("Router returned no usable points");

        renderRoute3D(pts);
        console.log("[ARK route] decision:", data.decision, "terms:", data.terms || "(n/a)");
        say("Route rendered (3D)");
      } catch (err) {
        console.error(err);
        say(`Error: ${err.message || err}`);
        throw err;
      }
    });

    // Annotate toggle
    document.getElementById('btnAnnotate').onclick = () => {
      if (!_ARK.inScene.available) { say("In-scene not available"); return; }
      openAnnotator().catch(e => { console.error(e); say("Annotator failed"); });
    };

    // ------------ Bootstrap
    const viewer = document.getElementById('mpv');
    (async () => {
      await customElements.whenDefined('matterport-viewer');
      const mpSdk = await viewer.playingPromise;
      status("SDK connected (WebComponent)");

      const S = mpSdk.Scene;
      if (S && typeof S.register==='function') {
        class ArkRoute {
          constructor() { this.inputs = { enabled: true }; this.outputs = {}; this.events = {}; this.emits = {}; }
          onInit() {
            const T = (this && this.THREE) || (typeof window !== "undefined" && window.THREE);
            if (!T) throw new Error("THREE not available from Scene");
            const root = new T.Group();
            this.outputs.objectRoot = root;

            _ARK.inScene.available = true;
            _ARK.inScene.THREE = T;
            _ARK.inScene.root = root;

            say("In-scene component initialized");
          }
          onTick() {}
          onDestroy() {
            _ARK.inScene.available = false;
            if (_ARK.inScene.routeMesh && _ARK.inScene.root) {
              _ARK.inScene.routeMesh.geometry?.dispose?.();
              _ARK.inScene.routeMesh.material?.dispose?.();
              _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
            }
            if (_ARK.inScene.pinsRoot && _ARK.inScene.root) {
              _ARK.inScene.root.remove(_ARK.inScene.pinsRoot);
              _ARK.inScene.pinsRoot = null;
            }
            _ARK.inScene.root = null;
            _ARK.inScene.THREE = null;
            _ARK.inScene.routeMesh = null;
          }
        }

        await S.register("arkRoute", () => new ArkRoute());
        const node = await S.createNode();
        try { node.addComponent("mp.lights", {}); } catch {}
        node.addComponent("arkRoute", {});
        await node.start();
      } else {
        throw new Error("Scene API not available");
      }

      try { mpSdk.Camera.pose.subscribe((p) => { _ARK.camera = p; }); }
      catch (err) { console.warn("[ARK] pose.subscribe failed", err); }
    })().catch(err => { console.error("[ARK] bootstrap failed:", err); throw err; });
  </script>
</body>
</html>