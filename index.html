<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ARK Safety Demo (WebComponent + Scene API)</title>

  <!-- Import map MUST be before the Matterport script -->
  <script type="importmap">
  {
    "imports": {
      "three": "./three-shim.js",
      "https://unpkg.com/three@%5E0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@^0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0/build/three.module.js?module": "./three-shim.js",
      "https://unpkg.com/three@0.176.0/build/three.module.js": "./three-shim.js"
    }
  }
  </script>

  <!-- Matterport WebComponent (ESM) -->
  <script type="module" src="https://unpkg.com/@matterport/webcomponent@0.1.45/dist/matterport-viewer.esm.js?module"></script>

  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e8edf2; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { display: flex; gap: .5rem; align-items: center; padding: .75rem 1rem; background: #11161d; border-bottom: 1px solid #1f2a37; }
    header .tag { font-weight: 600; opacity: .85; }
    header button { all: unset; background: #1f2a37; padding: .45rem .7rem; border-radius: .5rem; cursor: pointer; border: 1px solid #2b3949; }
    header button:hover { background:#243244; }
    header button:active { background:#1b2633; }
    header .spacer { flex: 1 1 auto; opacity:.6; font-size:.9rem; }
    .stage { position: relative; height: 100%; overflow: hidden; background: #000; }
    matterport-viewer { position: absolute; inset: 0; width: 100%; height: 100%; }
    .hud { position: absolute; left: 12px; bottom: 12px; background: rgba(9,12,17,.72); border: 1px solid rgba(64,86,110,.55); padding: .35rem .6rem; border-radius: .5rem; font-size: .85rem; user-select: none; }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <span class="tag">ARK</span>
      <button id="btnPlaceThreat">Place Threat</button>
      <button id="btnCompute">Compute Route</button>
      <button id="btnReset">Reset</button>
      <span class="spacer" id="status">Loading…</span>
    </header>

    <div class="stage">
      <matterport-viewer
        id="mpv"
        m="1ghABoaBFPZ"
        application-key="akqd0dp3hr9wz4eu70zd1rsab"
        asset-base="bundle"
        autoplay
        play>
      </matterport-viewer>

      <div class="hud" id="hud">Idle</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    // Fat-line renderer (examples). These modules import 'three' (uses our import map).
    import { Line2 }          from "https://unpkg.com/three@0.176.0/examples/jsm/lines/Line2.js?module";
    import { LineMaterial }   from "https://unpkg.com/three@0.176.0/examples/jsm/lines/LineMaterial.js?module";
    import { LineGeometry }   from "https://unpkg.com/three@0.176.0/examples/jsm/lines/LineGeometry.js?module";

    // ------------ Backend resolution (Cloudflare tunnel first)
    const params = new URLSearchParams(window.location.search);
    const API_PARAM = params.get("api");
    const HARD_WIRE = "https://assembly-paperbacks-eddie-combat.trycloudflare.com"; // <- your tunnel
    function resolveBackend() {
      if (API_PARAM) return API_PARAM.replace(/\/+$/,'');
      if (HARD_WIRE) return HARD_WIRE.replace(/\/+$/,'');
      const { protocol, hostname } = window.location;
      if (!/github\.io$/i.test(hostname)) return `${protocol}//${hostname}:7860`;
      console.warn("[ARK] Backend needs an https tunnel on github.io. Use ?api=https://<your-tunnel>/");
      return `${protocol}//${hostname}`;
    }
    const BACKEND_URL = resolveBackend();
    window.BACKEND_URL = BACKEND_URL; // expose for console debugging

    // ------------ UI helpers
    const hud = document.getElementById('hud');
    const statusEl = document.getElementById('status');
    const say = (m) => { hud.textContent = m; console.log('[ARK]', m); };
    const status = (m) => { statusEl.textContent = m; };

    // In-scene state
    const _ARK = {
      inScene: { available:false, THREE:null, root:null, routeMesh:null },
      camera: null,           // mpSdk camera pose (we'll pull start from here)
      threatWorld: null,      // {x,y,z} in Matterport world
      threatNav:   null       // {x,y} mapped to nav coords
    };

    // --------- Coordinate helpers (Matterport world → nav XY, and back)
    const ROUTE_Y = 0.10; // 10 cm above floor for visibility

    const worldToNav = (p) => ({ x: p.x, y: p.z });                 // floor plane: use XZ
    const navToWorld = (p) => new THREE.Vector3(p.x, ROUTE_Y, p.y); // lift off floor

    const anyPointToWorld = (p) => {
      if (Array.isArray(p)) {
        return (p.length >= 3)
          ? new THREE.Vector3(p[0], (p[1] ?? 0) + ROUTE_Y, p[2])
          : new THREE.Vector3(p[0], ROUTE_Y, p[1]);
      }
      if ("z" in p)   return new THREE.Vector3(p.x, (p.y ?? 0) + ROUTE_Y, p.z);
      // nav {x,y}
      return navToWorld(p);
    };

    // --------- Fat 3D line renderer (super visible)
    function renderRoute3D(points) {
      if (!_ARK.inScene.available) throw new Error("In-scene not available; cannot render 3D route");

      const root = _ARK.inScene.root;

      // clear old route
      if (_ARK.inScene.routeMesh) {
        if (_ARK.inScene.routeMesh.geometry) _ARK.inScene.routeMesh.geometry.dispose?.();
        if (_ARK.inScene.routeMesh.material) _ARK.inScene.routeMesh.material.dispose?.();
        root.remove(_ARK.inScene.routeMesh);
        _ARK.inScene.routeMesh = null;
      }

      if (!Array.isArray(points) || points.length < 2) throw new Error("renderRoute3D: invalid points");

      const positions = [];
      for (const p of points) {
        const v = anyPointToWorld(p);
        positions.push(v.x, v.y, v.z);
      }

      const geo = new LineGeometry();
      geo.setPositions(positions);

      const mat = new LineMaterial({
        color: 0x22ff88,       // bright neon green
        linewidth: 0.01,       // thick! (screen-space, with resolution set below)
        dashed: false,
        depthTest: false,      // draw on top of floor/furniture
        transparent: false
      });
      mat.resolution.set(window.innerWidth, window.innerHeight);

      const line = new Line2(geo, mat);
      line.computeLineDistances();

      root.add(line);
      _ARK.inScene.routeMesh = line;

      // keep width correct on resize
      const onResize = () => {
        if (_ARK.inScene.routeMesh?.material?.resolution) {
          _ARK.inScene.routeMesh.material.resolution.set(window.innerWidth, window.innerHeight);
        }
      };
      window.removeEventListener('resize', onResize);
      window.addEventListener('resize', onResize);
    }

    // ------------ Buttons
    document.getElementById('btnReset').addEventListener('click', () => {
      if (_ARK.inScene.routeMesh && _ARK.inScene.root) {
        if (_ARK.inScene.routeMesh.geometry) _ARK.inScene.routeMesh.geometry.dispose?.();
        if (_ARK.inScene.routeMesh.material) _ARK.inScene.routeMesh.material.dispose?.();
        _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
        _ARK.inScene.routeMesh = null;
      }
      _ARK.threatWorld = null;
      _ARK.threatNav = null;
      say('Reset');
    });

    document.getElementById('btnPlaceThreat').addEventListener('click', () => {
      if (!_ARK.camera?.position) { say("No camera pose yet"); return; }
      const pos = _ARK.camera.position;
      _ARK.threatWorld = { x: pos.x, y: pos.y, z: pos.z };
      _ARK.threatNav   = worldToNav(pos);
      say(`Threat set at camera (nav): (${_ARK.threatNav.x.toFixed(2)}, ${_ARK.threatNav.y.toFixed(2)})`);
    });

    document.getElementById('btnCompute').addEventListener('click', async () => {
      try {
        if (!_ARK.inScene.available) throw new Error("In-scene not available");
        if (!_ARK.camera?.position) throw new Error("No camera pose yet");
        if (!_ARK.threatNav) throw new Error("No threat set (click 'Place Threat' first)");

        const startNav = worldToNav(_ARK.camera.position);
        const threatNav = _ARK.threatNav;

        const res = await fetch(`${BACKEND_URL}/route/auto`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            start:  { x: startNav.x,  y: startNav.y  },
            threat: { x: threatNav.x, y: threatNav.y },
            k: 3, dx: 1.5,
            weights: { alpha: 1.0, beta: 12.0, gamma: 2.0, delta: 0.0 }
          })
        });

        const data = await res.json();
        if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);

        // Server may return either `route: [[x,y],...]` (nav) or `points: [{x,y,z}...]` (world)
        const pts = Array.isArray(data.route) ? data.route.map(([x,y]) => ({ x, y }))
                  : Array.isArray(data.points) ? data.points
                  : null;

        if (!pts || pts.length < 2) throw new Error("Router returned no usable points");

        renderRoute3D(pts);
        console.log("[ARK route] decision:", data.decision, "terms:", data.terms || "(n/a)");
        say("Route rendered (3D)");
      } catch (err) {
        console.error(err);
        say(`Error: ${err.message || err}`);
        throw err; // surface crashes
      }
    });

    // ------------ Bootstrap
    const viewer = document.getElementById('mpv');

    (async () => {
      await customElements.whenDefined('matterport-viewer');
      const mpSdk = await viewer.playingPromise;
      status("SDK connected (WebComponent)");

      const S = mpSdk.Scene;
      if (S && typeof S.register==='function') {
        class ArkRoute {
          constructor() {
            // non-empty so SDK adds .onChanged hooks internally
            this.inputs  = { enabled: true };
            this.outputs = {};
            this.events  = {};
            this.emits   = {};
          }
          onInit() {
            const T = THREE;
            const root = new T.Group();
            this.outputs.objectRoot = root;  // set AFTER SDK setup of outputs

            _ARK.inScene.available = true;
            _ARK.inScene.THREE = T;
            _ARK.inScene.root = root;

            say("In-scene component initialized");
          }
          onTick() {}
          onDestroy() {
            _ARK.inScene.available = false;
            if (_ARK.inScene.routeMesh && _ARK.inScene.root) {
              if (_ARK.inScene.routeMesh.geometry) _ARK.inScene.routeMesh.geometry.dispose?.();
              if (_ARK.inScene.routeMesh.material) _ARK.inScene.routeMesh.material.dispose?.();
              _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
            }
            _ARK.inScene.root = null;
            _ARK.inScene.THREE = null;
            _ARK.inScene.routeMesh = null;
          }
        }

        await S.register("arkRoute", () => new ArkRoute());
        const node = await S.createNode();

        // Optional: lights (safe; always pass {})
        try { node.addComponent("mp.lights", {}); } catch {}

        node.addComponent("arkRoute", {});
        await node.start();
      } else {
        throw new Error("Scene API not available");
      }

      // Keep the latest camera pose (start & threat capture)
      try {
        mpSdk.Camera.pose.subscribe((p) => { _ARK.camera = p; });
      } catch (err) {
        console.warn("[ARK] pose.subscribe failed", err);
      }
    })().catch(err => { console.error("[ARK] bootstrap failed:", err); throw err; });
  </script>
</body>
</html>