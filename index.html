<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Ark Active Threat – Phase 1 (SDK)</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { height: 100%; margin: 0; }
    body { background:#0b0b0b; color:#e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #wrap { position: relative; height: 100%; width: 100%; overflow: hidden; }
    iframe#mp { position: absolute; inset: 0; width: 100%; height: 100%; border: 0; background:#000; }

    #hud {
      position: absolute; top: 10px; left: 10px; z-index: 30;
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      background: rgba(0,0,0,.55); padding: 12px; border-radius: 12px; backdrop-filter: blur(6px);
      box-shadow: 0 6px 20px rgba(0,0,0,.35);
    }
    .group { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .field {
      display:flex; flex-direction:column; gap:6px; font-size:12px;
      background:rgba(255,255,255,.04); padding:8px 10px; border-radius:8px;
    }
    .field input {
      all: unset; padding:6px 8px; border-radius:6px; background: rgba(255,255,255,.06);
      outline: 1px solid rgba(255,255,255,.12); font-size: 13px; width: 110px;
    }
    .btn {
      all: unset; cursor: pointer; font-weight:600; padding:8px 12px; border-radius:8px;
      background: linear-gradient(180deg, #2a2a2a, #181818); outline:1px solid rgba(255,255,255,.16);
    }
    .btn:active { transform: translateY(1px); }
    .pill {
      background: rgba(255,255,255,.06); padding:8px 10px; border-radius:9999px; font-size:12px;
      outline:1px solid rgba(255,255,255,.12);
      display:inline-flex; align-items:center; gap:8px;
    }

    #overlay { position:absolute; inset:0; pointer-events:none; }
    #routeLayer { position:absolute; inset:0; width:100%; height:100%; pointer-events:auto; }
    #legend {
      position:absolute; right:10px; bottom:10px; z-index:25; font-size:12px; opacity:.75;
      background: rgba(0,0,0,.5); padding:6px 8px; border-radius:8px; outline:1px solid rgba(255,255,255,.12);
    }

    #loading {
      position:absolute; inset:0; display:grid; place-items:center; z-index:40; pointer-events:none;
      background: radial-gradient(80% 80% at 50% 20%, rgba(255,255,255,.08), transparent 70%);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <iframe id="mp" title="Matterport" allow="vr; xr; fullscreen"></iframe>

    <div id="hud" role="toolbar" aria-label="Controls">
      <div class="group">
        <span class="pill">Mode: Route (Phase 1)</span>
        <button class="btn" id="btnFullscreen">Fullscreen</button>
      </div>

      <div class="group" style="gap:16px; border-left:1px solid #2a2a2a; padding-left:12px;">
        <div class="field">
          <label>Start X (m)</label>
          <input id="sx" type="number" step="0.1" value="0">
        </div>
        <div class="field">
          <label>Start Y (m)</label>
          <input id="sy" type="number" step="0.1" value="0">
        </div>
        <div class="field">
          <label>Goal X (m)</label>
          <input id="gx" type="number" step="0.1" value="20">
        </div>
        <div class="field">
          <label>Goal Y (m)</label>
          <input id="gy" type="number" step="0.1" value="10">
        </div>
        <button class="btn" id="btnRoute">Compute Route</button>
      </div>

      <!-- NEW: capture + export + reset -->
      <div class="group" style="gap:12px; border-left:1px solid #2a2a2a; padding-left:12px;">
        <label class="pill" title="Hold Shift and click on the plan to capture a point">
          <input id="captureMode" type="checkbox" /> Capture Mode
        </label>
        <button class="btn" id="btnDownloadDest">Download destinations.json</button>
        <button class="btn" id="btnReset">Reset Overlay</button>
      </div>

      <div id="stats" class="pill">Length: —</div>
    </div>

    <div id="overlay">
      <canvas id="routeLayer"></canvas>
      <div id="legend">Route overlay scaled to site bounds (not yet georegistered to view)</div>
    </div>

    <div id="loading">
      <div class="pill">Loading…</div>
    </div>
  </div>

  <script>
    // ---------- DOM ----------
    const wrap = document.getElementById("wrap");
    const mp   = document.getElementById("mp");
    const cvs  = document.getElementById("routeLayer");
    const ctx  = cvs.getContext("2d");
    const loading = document.getElementById("loading");
    const stats   = document.getElementById("stats");

    let SITE_BBOX = null;        // {min:[x,y], max:[x,y]}
    let SCALE     = { s:1, offx:0, offy:0 };

    // ---------- Utils ----------
    const info  = (...a)=>console.log("[INFO]", ...a);
    const warn  = (...a)=>console.warn("[WARN]", ...a);
    const error = (...a)=>console.error("[ERR ]", ...a);

    function setLoading(on){
      loading.style.display = on ? "grid" : "none";
    }

    // Compute fitted scale from SITE_BBOX to canvas
    function fitFromBBox() {
      const W = cvs.width, H = cvs.height;
      if (!SITE_BBOX) { SCALE = {s:1, offx:0, offy:0}; return; }
      const [minx, miny] = SITE_BBOX.min;
      const [maxx, maxy] = SITE_BBOX.max;
      const pad = 30;

      const rw = Math.max(1e-6, maxx - minx);
      const rh = Math.max(1e-6, maxy - miny);

      const sx = (W - 2*pad) / rw;
      const sy = (H - 2*pad) / rh;
      const s  = Math.min(sx, sy);

      const offx = pad - minx*s + (W - 2*pad - rw*s)/2;
      const offy = pad - miny*s + (H - 2*pad - rh*s)/2;

      SCALE = {s, offx, offy};
    }

    function worldToCanvas(x, y) {
      const W = cvs.width, H = cvs.height;
      const {s, offx, offy} = SCALE;
      const px =  x*s + offx;
      const py =  H - (y*s + offy);   // Y-up meters -> Y-down pixels
      return [px, py];
    }

    function resizeCanvas(){
      cvs.width  = wrap.clientWidth;
      cvs.height = wrap.clientHeight;
      fitFromBBox();
      if (window._lastRoute) drawRoute(window._lastRoute);
    }
    window.addEventListener("resize", resizeCanvas);

    function drawRoute(route){
      const W = cvs.width, H = cvs.height;
      ctx.clearRect(0,0,W,H);
      if(!route || route.length < 2) return;

      ctx.lineWidth = 4;
      ctx.lineJoin = "round";
      ctx.lineCap  = "round";

      ctx.beginPath();
      route.forEach(([x,y], i)=>{
        const [px,py] = worldToCanvas(x,y);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      });
      ctx.strokeStyle = "#00aa66";
      ctx.shadowColor = "#00aa66";
      ctx.shadowBlur = 6;
      ctx.stroke();
      ctx.shadowBlur = 0;

      // breadcrumbs
      ctx.fillStyle = "#00aa66";
      const step = 1.0; // meters
      let acc = 0;
      for (let i=1; i<route.length; i++){
        const [ax,ay] = route[i-1], [bx,by] = route[i];
        const dx = bx-ax, dy=by-ay;
        const seg = Math.hypot(dx,dy);
        while (acc <= seg) {
          const t = acc/seg;
          const x = ax + dx*t, y = ay + dy*t;
          const [px,py] = worldToCanvas(x,y);
          ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2); ctx.fill();
          acc += step;
        }
        acc -= seg;
      }
    }

    // ---------- Server helpers ----------
    async function fetchSiteMeta(){
      // Get bbox from server (or compute from nav if needed)
      try {
        const r = await fetch('/site/meta.json');
        if (r.ok) {
          const m = await r.json();
          SITE_BBOX = m.bbox;
          return;
        }
      } catch {}
      // Fallback: ask server for a route (Phase 1.0 saved a sample)
      // If none, leave default SCALE.
    }

    async function requestRoute(sx,sy,gx,gy){
      const r = await fetch(`/route?sx=${sx}&sy=${sy}&gx=${gx}&gy=${gy}`);
      if(!r.ok) throw new Error(await r.text());
      return await r.json();
    }

    // ---------- HUD wiring ----------
    document.getElementById("btnFullscreen").onclick = ()=> {
      if (document.fullscreenElement) document.exitFullscreen();
      else wrap.requestFullscreen();
    };

    document.getElementById("btnRoute").onclick = async ()=>{
      try{
        setLoading(true);
        const sx = parseFloat(document.getElementById("sx").value);
        const sy = parseFloat(document.getElementById("sy").value);
        const gx = parseFloat(document.getElementById("gx").value);
        const gy = parseFloat(document.getElementById("gy").value);
        const out = await requestRoute(sx,sy,gx,gy);

        // If server returns bbox the first time, fit canvas to it
        if (!SITE_BBOX && out?.route?.length >= 2) {
          const xs = out.route.map(p=>p[0]);
          const ys = out.route.map(p=>p[1]);
          SITE_BBOX = {
            min: [Math.min(...xs), Math.min(...ys)],
            max: [Math.max(...xs), Math.max(...ys)]
          };
          fitFromBBox();
        }

        window._lastRoute = out.route;
        stats.textContent = `Length: ${out.length_m?.toFixed(1)} m`;
        drawRoute(out.route);
      }catch(e){
        alert(e.message || e);
      }finally{
        setLoading(false);
      }
    };

    // ---------- SDK boot ----------
    (async function boot(){
      setLoading(true);

      // 1) load Showcase (embed)
      const modelId = new URLSearchParams(location.search).get("m") || "1ghABoaBFPZ";
      const isProd = location.hostname.endsWith(".github.io");
      const origin = isProd ? "https://my.matterport.com" : "https://my.matterport.com";
      const url = `${origin}/show/?m=${modelId}&applicationKey=${encodeURIComponent('REDACTED_APP_KEY')}&play=1&qs=1&brand=0&dh=0`;
      mp.src = url;

      // 2) Connect SDK (optional for Phase 1.0 overlay)
      let _sdk = null;
      async function connectShowcase(timeoutMs=15000){
        const t0=performance.now();
        while (performance.now() - t0 < timeoutMs) {
          try {
            const w = mp.contentWindow;
            if (w?.MP_SDK?.connect) {
              const sdk = await w.MP_SDK.connect(w, APPKEY);
              window._mpSdk = _sdk = sdk;
              info("SDK connected");
              setLoading(false);
              return sdk;
            }
          } catch(e) { /* retry loop */ }
          await new Promise(r=>setTimeout(r, 200));
        }
        throw new Error("Timed out waiting for MP_SDK.connect");
      }

      /********* FIT + DRAW *********/
      function fitFromBBox() {
        const W = cvs.width, H = cvs.height;
        if (!SITE_BBOX) { SCALE = {s:1, offx:0, offy:0}; return; }
        const [minx, miny] = SITE_BBOX.min;
        const [maxx, maxy] = SITE_BBOX.max;
        const pad = 30;

        const rw = Math.max(1e-6, maxx - minx);
        const rh = Math.max(1e-6, maxy - miny);

        const sx = (W - 2*pad) / rw;
        const sy = (H - 2*pad) / rh;
        const s  = Math.min(sx, sy);

        const offx = pad - minx*s + (W - 2*pad - rw*s)/2;
        const offy = pad - miny*s + (H - 2*pad - rh*s)/2;

        SCALE = {s, offx, offy};
      }

      window.addEventListener("load", async ()=>{
        resizeCanvas();
        try {
          await connectShowcase(15000);  // sets window._mpSdk on success
        } catch (e) {
          error(e);
          // Keep UI usable even if SDK connect fails; overlay will still work
          setLoading(false);
        }
      }, { once:true });

      // 3) pull site bbox for consistent scaling
      await fetchSiteMeta();
      fitFromBBox();
    })();

    /* ==================== PHASE 1.1 ADDITIONS ==================== */

    // In-memory capture store
    const CAPTURE = { exits: [], shelters: [] };

    function canvasToWorld(px, py) {
      const W = cvs.width, H = cvs.height;
      const {s, offx, offy} = SCALE || {s:1, offx:0, offy:0};
      const x = (px - offx) / s;
      const y = ((H - py) - offy) / s;
      return [x, y];
    }

    function drawMarkers() {
      const W = cvs.width, H = cvs.height;
      const R = 5;
      ctx.save();
      // exits: green
      ctx.fillStyle = '#2ecc71';
      for (const p of CAPTURE.exits) {
        const [px, py] = worldToCanvas(p.x, p.y);
        ctx.beginPath(); ctx.arc(px, py, R, 0, Math.PI*2); ctx.fill();
      }
      // shelters: blue
      ctx.fillStyle = '#3498db';
      for (const p of CAPTURE.shelters) {
        const [px, py] = worldToCanvas(p.x, p.y);
        ctx.beginPath(); ctx.arc(px, py, R, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    // augment drawRoute to also draw markers
    const __origDrawRoute = drawRoute;
    drawRoute = function(route){
      __origDrawRoute(route);
      drawMarkers();
    };

    // also re-draw markers on resize
    const __origResizeCanvas = resizeCanvas;
    resizeCanvas = function(){
      __origResizeCanvas();
      drawMarkers();
    };

    // Click capture handler on canvas (Shift+Click)
    cvs.addEventListener('click', (e) => {
      const cap = document.getElementById('captureMode');
      if (!cap || !cap.checked || !e.shiftKey) return;
      const rect = cvs.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const [x, y] = canvasToWorld(px, py);
      const label = prompt('Label this point as exit:<name> or shelter:<name>', 'exit:front');
      if (!label) return;
      const parts = String(label).split(':');
      const kind = (parts[0] || '').trim().toLowerCase();
      const id = (parts[1] || ('p' + Date.now())).trim();
      const rec = { id, x: +x, y: +y, z: 0 };
      if (kind === 'exit') CAPTURE.exits.push(rec);
      else CAPTURE.shelters.push(rec);
      drawMarkers();
    });

    // Download destinations.json
    document.getElementById('btnDownloadDest').addEventListener('click', () => {
      const blob = new Blob([JSON.stringify({exits: CAPTURE.exits, shelters: CAPTURE.shelters}, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'destinations.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // Reset overlay (clears route but keeps captured points)
    document.getElementById('btnReset').addEventListener('click', () => {
      window._lastRoute = null;
      ctx.clearRect(0,0,cvs.width,cvs.height);
      drawMarkers();
      stats.textContent = 'Length: —';
    });
  </script>
</body>
</html>