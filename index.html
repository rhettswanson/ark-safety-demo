<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ARK Safety Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- (unchanged) base styles -->
  <style>
    :root {
      --bg:#0b1118; --panel:#0f1520; --ink:#e8edf2; --muted:#9fb0c3;
      --line:#35ff87; --accent:#5dd6ff; --pink:#ff66cc;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--ink); font:14px/1.3 Inter,system-ui,Segoe UI,Arial,sans-serif; }
    #app { position:fixed; inset:0; display:flex; flex-direction:column; }
    header { display:flex; gap:.5rem; align-items:center; padding:.5rem .75rem; background:#0e141d; border-bottom:1px solid #1f2a37; }
    header .spacer { flex:1 1 auto; opacity:.8; font-size:.92rem; }
    header button { all:unset; background:#1f2a37; border:1px solid #2b3949; padding:.35rem .7rem; border-radius:.5rem; cursor:pointer; }
    header button:hover { background:#263447; }
    #stage { position:relative; flex:1 1 auto; overflow:hidden; }
    matterport-viewer { position:absolute; inset:0; }

    .hud { position:absolute; left:.75rem; bottom:.75rem; background:rgba(15,20,27,.9);
      border:1px solid #263447; border-radius:.5rem; padding:.35rem .6rem; font-size:.85rem; z-index:1030; }
    .ok { color:#6ff2a6 } .warn{ color:#ffd26f } .err{ color:#ff8b8b }

    /* ──────────────────────────────────────────────────────────────
       Annotator (UPDATED)
       ────────────────────────────────────────────────────────────── */
    .annot {
      position:absolute; top:0; right:0; width:460px; height:100%;
      background:rgba(15,20,27,.96); border-left:1px solid #263447;
      display:none; flex-direction:column; z-index:10050; overflow:hidden;
    }
    .annot.show { display:flex; }

    .annot .head {
      display:flex; flex-wrap:wrap; gap:.5rem; align-items:center;
      padding:.6rem .8rem; border-bottom:1px solid #223042;
    }
    .annot .head .title { flex:0 0 100%; font-weight:600; }

    .annot .head input[type="text"],
    .annot .head input[type="number"]{
      background:#0f1520; color:#e8edf2; border:1px solid #2b3949;
      border-radius:.45rem; padding:.35rem .5rem;
    }
    .annot .head .grow { flex:1 1 180px; min-width:160px; } /* filter */
    .annot .head .w72  { width:72px; }  /* min conf */
    .annot .head .w64  { width:64px; }  /* nudge step */

    .annot .head button {
      all:unset; background:#1f2a37; border:1px solid #2b3949;
      padding:.3rem .6rem; border-radius:.45rem; cursor:pointer;
    }
    .annot .head button:hover { background:#243244; }

    /* ensure the list always renders and scrolls (UPDATED) */
    .annot .body { flex:1 1 auto; overflow:auto; padding:.6rem; display:flex; gap:.6rem; flex-direction:column; }
    .annot .foot { margin-top:auto; padding:.6rem; border-top:1px solid #223042; display:flex; gap:.5rem; }

    .row { display:grid; grid-template-columns: 84px 1fr auto; gap:.4rem; background:#0e1420; border:1px solid #223042; border-radius:.5rem; padding:.5rem; align-items:center; }
    .row select, .row input { background:#0f1520; color:#e8edf2; border:1px solid #2b3949; border-radius:.35rem; padding:.3rem .45rem; }
    .row .id { color:var(--muted); font-size:.82rem; }
    .row .btn { all:unset; padding:.25rem .45rem; border-radius:.35rem; background:#1f2a37; border:1px solid #2b3949; cursor:pointer; }
    .row .btn:hover { background:#243244; }

    .tip { position:absolute; left:.75rem; bottom:2.4rem; font-size:.82rem; color:var(--muted); z-index:1030; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <strong>ARK</strong>
    <button id="btnThreat">Place Threat</button>
    <button id="btnRoute">Compute Route</button>
    <button id="btnReset">Reset</button>
    <div class="spacer" id="sdkState">SDK connecting…</div>
    <button id="btnAnnotate">Annotate</button>
  </header>

  <div id="stage">
    <!-- Matterport WebComponent (unchanged model id) -->
    <matterport-viewer id="viewer" applicationKey="mp_web_component" src="https://my.matterport.com/show/?m=1gHBA08BPFZ&play=1&qs=1"></matterport-viewer>

    <div class="hud" id="hud">Idle</div>
    <div class="tip">Tip: center the doorway (floorplan or 3D) then click <b>Add here</b>. Use ← ↑ → ↓ to nudge by the step size. Pink flash confirms changes.</div>

    <!-- Annotate panel (UPDATED header + body) -->
    <div class="annot" id="annot">
      <div class="head">
        <div class="title">Annotate Doors</div>
        <input id="annotFilter" class="grow" type="text" placeholder="filter by label/id" />
        <input id="annotConfMin" class="w72" type="number" step="0.01" min="0" max="1" value="0" title="min confidence (0..1)" />
        <input id="annotStep" class="w64" type="number" step="0.05" min="0.01" value="0.25" title="nudge step (meters)" />
        <button id="annotAddHere">Add here</button>
        <button id="annotAuto">Auto meta</button>
        <button id="annotSave">Save</button>
        <button id="annotClose">Close</button>
      </div>
      <div class="body" id="annotBody"><!-- rows injected --></div>
      <div class="foot" id="annotFoot"></div>
    </div>
  </div>
</div>

<script type="module">
/* ============================================================
   Small helpers / status
   ============================================================ */
const hud = document.getElementById('hud');
const say = (m) => { hud.textContent = m; console.log('[ARK]', m); };
const statusEl = document.getElementById('sdkState');

function backendURL() {
  const host = location.hostname;
  if (/github\.io$/i.test(host)) return 'https://alternatively-presently-cooperative-submitting.trycloudflare.com'; // your CF tunnel
  return `${location.protocol}//${host}:7860`;
}
const BACKEND_URL = backendURL();

/* ============================================================
   Connect to Matterport WebComponent
   ============================================================ */
const viewer = document.getElementById('viewer');
await viewer.playingPromise;                         // ensure player is live
const mpSdk = await viewer.getSdk();                 // MP SDK
statusEl.textContent = 'SDK connected (WebComponent)';

/* ============================================================
   In-scene component (unchanged core; inputs/outputs defined early)
   ============================================================ */
const Scene = mpSdk.Scene;
if (Scene && typeof Scene.register === 'function') {
  class ArkRoute {
    constructor(){
      /* define before SDK wraps them → prevents hasOwnProperty crash */
      this.inputs = {}; this.outputs = {}; this.events = {}; this.emits = {};
    }
    onInit(ctx){
      const T = ctx.three;
      const root = new T.Group();
      this.outputs.objectRoot = root;   // set AFTER setupOutputs has run
      _ARK.inScene = _ARK.inScene || {};
      _ARK.inScene.available = true;
      _ARK.inScene.THREE = T;
      _ARK.inScene.root = root;
      say('In-scene component initialized');
    }
    onTick() {}
    onDestroy(){
      _ARK.inScene = { available:false, root:null, THREE:null, routeMesh:null };
    }
  }
  await Scene.register('arkRoute', () => new ArkRoute());

  // Create a node & attach our component on start
  (async ()=>{
    const node = await Scene.createNode();
    try { node.addComponent('mp.lights', {}); } catch {}
    node.addComponent('arkRoute', {});
    await node.start();
  })();
} else {
  console.warn('[ARK] Scene API not available; overlay fallback.');
}

/* ============================================================
   App state
   ============================================================ */
const _ARK = {
  inScene: { available:false, root:null, THREE:null, routeMesh:null },
  annot: [],      // { id, type, label, x, y, conf }
  pins: [],       // THREE.Mesh (spheres)
  pinMat: null,
};

/* ============================================================
   Minimal 3D line renderer (unchanged)
   ============================================================ */
function drawRoute3D(points /* [{x,y}] in nav meters */){
  const S = _ARK.inScene;
  if (!S.available) return;

  const T = S.THREE, root = S.root;
  const verts = [];
  for (const p of points) verts.push(p.x, 0.05, p.y); // small lift to avoid z-fighting

  const geo = new T.BufferGeometry();
  geo.setAttribute('position', new T.Float32BufferAttribute(verts, 3));
  const mat = new T.LineBasicMaterial({ color: 0x34ff7a, linewidth: 2 });
  const line = new T.Line(geo, mat);

  if (S.routeMesh) root.remove(S.routeMesh);
  root.add(line); S.routeMesh = line;

  say('Route rendered (3D)');
}

/* ============================================================
   Buttons
   ============================================================ */
document.getElementById('btnReset').addEventListener('click', ()=>{
  if (_ARK.inScene.routeMesh && _ARK.inScene.root) {
    _ARK.inScene.root.remove(_ARK.inScene.routeMesh);
    _ARK.inScene.routeMesh = null;
  }
  say('Reset');
});

document.getElementById('btnThreat').addEventListener('click', async ()=>{
  // Demo: place threat at camera nav position
  const pose = await mpSdk.Camera.getPose();
  const nav = { x: pose.position.x, y: pose.position.z }; // MP uses y-up; navgraph uses x,z
  _ARK.lastThreat = { x: nav.x, y: nav.y };
  console.log('[ARK] Threat set at camera (nav):', nav);
});

document.getElementById('btnRoute').addEventListener('click', async ()=>{
  try {
    const pose = await mpSdk.Camera.getPose();
    const nav = { x: pose.position.x, y: pose.position.z };
    const body = {
      start: nav,
      threat: _ARK.lastThreat || nav,
      prefer: "exit",                 // exits first, then shelters
      robust_k: 3,                    // small uncertainty sweep
    };
    const res = await fetch(`${BACKEND_URL}/route_safe`, {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
    });
    const js = await res.json();
    console.log('[ARK route] decision:', js.decision, js.terms);
    drawRoute3D(js.path);
  } catch (err) {
    console.error(err); say('Route failed');
  }
});

/* ============================================================
   Annotate UI
   ============================================================ */
const annot = document.getElementById('annot');
const annotFilter = document.getElementById('annotFilter');
const annotConfMin = document.getElementById('annotConfMin');
const annotStep = document.getElementById('annotStep');
const annotBody = document.getElementById('annotBody');

document.getElementById('btnAnnotate').addEventListener('click', openAnnotator);
document.getElementById('annotClose').addEventListener('click', ()=>annot.classList.remove('show'));
document.getElementById('annotSave').addEventListener('click', saveDestinations);
document.getElementById('annotAuto').addEventListener('click', loadAutoMeta);
document.getElementById('annotAddHere').addEventListener('click', addHere);

/* show then render to avoid rendering into display:none */
function openAnnotator(){
  annot.classList.add('show');
  renderAnnotList();
  buildPins();
}

/* rows */
function renderAnnotList(){
  const q = (annotFilter.value||'').trim().toLowerCase();
  const confMin = Number(annotConfMin.value||0);

  annotBody.innerHTML = '';
  _ARK.annot.forEach((d,idx)=>{
    if (q && !(String(d.id).toLowerCase().includes(q) || (d.label||'').toLowerCase().includes(q))) return;
    if (d.conf != null && d.conf < confMin) return;

    const row = document.createElement('div');
    row.className = 'row';
    row.innerHTML = `
      <select data-k="type">
        <option value="None"${d.type==='None'?' selected':''}>None</option>
        <option value="Exit"${d.type==='Exit'?' selected':''}>Exit</option>
        <option value="Shelter"${d.type==='Shelter'?' selected':''}>Shelter</option>
      </select>
      <input data-k="label" type="text" placeholder="Label (e.g., Exit for Room 203)" value="${d.label||''}" />
      <div class="id">#${d.id} · (${d.x.toFixed(2)}, ${d.y.toFixed(2)})</div>
    `;
    row.querySelectorAll('select,input').forEach(el=>{
      el.addEventListener('input', (e)=>{
        const k = e.target.getAttribute('data-k');
        _ARK.annot[idx][k] = e.target.value;
      });
    });
    annotBody.appendChild(row);
  });
}

/* build pink pin meshes */
function buildPins(){
  const S = _ARK.inScene;
  if (!S.available) return;
  const T = S.THREE, root = S.root;

  // clear old
  _ARK.pins.forEach(p => root.remove(p));
  _ARK.pins.length = 0;

  if (!_ARK.pinMat) _ARK.pinMat = new T.MeshStandardMaterial({ color: 0xff66cc, emissive: 0x441122, roughness:.8, metalness:.2 });

  for (const d of _ARK.annot){
    const geo = new T.SphereGeometry(0.12, 20, 16);
    const mesh = new T.Mesh(geo, _ARK.pinMat);
    mesh.position.set(d.x, 0.12, d.y);
    _ARK.pins.push(mesh); root.add(mesh);
  }
}

/* small flash helper */
function flashPinColor(idx, color, ms=800){
  const p = _ARK.pins[idx]; if (!p) return;
  const old = _ARK.pinMat.color.getHex();
  _ARK.pinMat.color.setHex(color);
  setTimeout(()=>_ARK.pinMat.color.setHex(old), ms);
}

/* ADD HERE — UPDATED tail to guarantee the row appears */
async function addHere(){
  try{
    const pose = await mpSdk.Camera.getPose();
    // nav meters: use x / z
    const nav = { x: pose.position.x, y: pose.position.z };
    const id = Date.now();
    _ARK.annot.push({ id, type:'None', label:'', x:nav.x, y:nav.y, conf:null });

    const idx = _ARK.annot.length - 1;

    // render list & pins
    renderAnnotList();
    buildPins();

    // If filters hide the fresh row, clear them and re-render
    const body = document.getElementById('annotBody');
    if (!body || body.children.length === 0){
      annotFilter.value = '';
      annotConfMin.value = '0';
      renderAnnotList();
    }

    flashPinColor(idx, 0xff66cc, 1200);
    say(`Added pin at (${nav.x.toFixed(2)}, ${nav.y.toFixed(2)})`);
  }catch(err){
    console.error(err); say('Add failed');
  }
}

/* Load auto doors (still optional; filters out-of-bounds if any) */
async function loadAutoMeta(){
  try{
    const res = await fetch('./doors_auto.json', { cache:'no-store' });
    if (!res.ok) throw new Error(`doors_auto.json ${res.status}`);
    const js = await res.json();
    let added = 0;
    for (const d of js){
      if (!isFinite(d.x) || !isFinite(d.y)) continue;
      _ARK.annot.push({ id: d.id ?? Date.now()+Math.random()*1000|0, type:'None', label: d.label ?? '', x:d.x, y:d.y, conf:d.conf ?? null });
      added++;
    }
    say(`Auto meta: ${added} added`);
    renderAnnotList(); buildPins();
  } catch (err) {
    console.warn(err); say('Auto meta failed');
  }
}

/* Save to backend */
async function saveDestinations(){
  try {
    const body = { items: _ARK.annot };
    const res = await fetch(`${BACKEND_URL}/save_destinations`, {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
    });
    if (!res.ok) throw new Error(`${res.status}`);
    say('Saved');
  } catch (err) {
    console.error(err); say('Save failed');
  }
}
</script>
</body>
</html>